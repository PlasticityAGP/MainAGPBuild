<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Assembly-CSharp-firstpass</name>
    </assembly>
    <members>
        <member name="T:Cinemachine.CinemachineBlendListCamera">
            <summary>
            This is a virtual camera "manager" that owns and manages a collection
            of child Virtual Cameras.  When the camera goes live, these child vcams 
            are enabled, one after another, holding each camera for a designated time.  
            Blends between cameras are specified.
            The last camera is held indefinitely.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_LookAt">
            <summary>Default object for the camera children to look at (the aim target), if not specified in a child rig.  May be empty</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_Follow">
            <summary>Default object for the camera children wants to move with (the body target), if not specified in a child rig.  May be empty</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_ShowDebugText">
            <summary>When enabled, the current camera and blend will be indicated in the game window, for debugging</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_EnableAllChildCameras">
            <summary>Force all child cameras to be enabled.  This is useful if animating them in Timeline, but consumes extra resources.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_ChildCameras">
            <summary>Internal API for the editor.  Do not use this field</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlendListCamera.Instruction">
            <summary>This represents a single entry in the instrunction list of the BlendListCamera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.Instruction.m_VirtualCamera">
            <summary>The virtual camera to activate when this instruction becomes active</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.Instruction.m_Hold">
            <summary>How long to wait (in seconds) before activating the next virtual camera in the list (if any)</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.Instruction.m_Blend">
            <summary>How to blend to the next virtual camera in the list (if any)</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.m_Instructions">
            <summary>The set of instructions associating virtual cameras with states.  
            The set of instructions for enabling child cameras</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.Description">
            <summary>Gets a brief debug description of this virtual camera, for use when displayiong debug info</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.LiveChild">
            <summary>Get the current "best" child virtual camera, that would be chosen
            if the State Driven Camera were active.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.LiveChildOrSelf">
            <summary>Return the live child.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.State">
            <summary>The State of the current live child</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.LookAt">
            <summary>Get the current LookAt target.  Returns parent's LookAt if parent
            is non-null and no specific LookAt defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.Follow">
            <summary>Get the current Follow target.  Returns parent's Follow if parent
            is non-null and no specific Follow defined for this camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Cinemachine.CinemachineBlendListCamera.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)" -->
        <member name="M:Cinemachine.CinemachineBlendListCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  This implementation
            updates all the children, chooses the best one, and implements any required blending.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.OnEnable">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.OnTransformChildrenChanged">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.OnGUI">
            <summary>Displays the current active camera on the game screen, if requested</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.ChildCameras">
            <summary>The list of child cameras.  These are just the immediate children in the hierarchy.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlendListCamera.IsBlending">
            <summary>Is there a blend in progress?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendListCamera.mActivationTime">
            <summary>The time at which the current instruction went live</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendListCamera.ValidateInstructions">
            <summary>Internal API for the inspector editor.</summary>
            // GML todo: make this private, part of UpdateListOfChildren()
        </member>
        <member name="T:Cinemachine.CinemachineBrain">
            <summary>
            CinemachineBrain is the link between the Unity Camera and the Cinemachine Virtual 
            Cameras in the scene.  It monitors the priority stack to choose the current 
            Virtual Camera, and blend with another if necessary.  Finally and most importantly, 
            it applies the Virtual Camera state to the attached Unity Camera.
            
            The CinemachineBrain is also the place where rules for blending between virtual cameras 
            are defined.  Camera blending is an interpolation over time of one virtual camera 
            position and state to another. If you think of virtual cameras as cameramen, then 
            blending is a little like one cameraman smoothly passing the camera to another cameraman. 
            You can specify the time over which to blend, as well as the blend curve shape. 
            Note that a camera cut is just a zero-time blend.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_ShowDebugText">
            <summary>
            When enabled, the current camera and blend will be indicated in the game window, for debugging.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_ShowCameraFrustum">
            <summary>
            When enabled, shows the camera's frustum in the scene view.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_IgnoreTimeScale">
            <summary>
            When enabled, the cameras will always respond in real-time to user input and damping, 
            even if the game is running in slow motion
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_WorldUpOverride">
            <summary>
            If set, this object's Y axis will define the worldspace Up vector for all the
            virtual cameras.  This is useful in top-down game environments.  If not set, Up is worldspace Y.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBrain.UpdateMethod">
            <summary>This enum defines the options available for the update method.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.UpdateMethod.FixedUpdate">
            <summary>Virtual cameras are updated in sync with the Physics module, in FixedUpdate</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.UpdateMethod.LateUpdate">
            <summary>Virtual cameras are updated in MonoBehaviour LateUpdate.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.UpdateMethod.SmartUpdate">
            <summary>Virtual cameras are updated according to how the target is updated.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_UpdateMethod">
            <summary>Depending on how the target objects are animated, adjust the update method to
            minimize the potential jitter.  Use FixedUpdate if all your targets are animated with for RigidBody animation.
            SmartUpdate will choose the best method for each virtual camera, depending
            on how the target is animated.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_DefaultBlend">
            <summary>
            The blend which is used if you don't explicitly define a blend between two Virtual Cameras.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_CustomBlends">
            <summary>
            This is the asset which contains custom settings for specific blends.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.OutputCamera">
            <summary>
            Get the Unity Camera that is attached to this GameObject.  This is the camera
            that will be controlled by the brain.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBrain.BrainEvent">
            <summary>Event with a CinemachineBrain parameter</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBrain.VcamEvent">
            <summary>Event with a ICinemachineCamera parameter</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_CameraCutEvent">
            <summary>This event will fire whenever a virtual camera goes live and there is no blend</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.m_CameraActivatedEvent">
            <summary>This event will fire whenever a virtual camera goes live.  If a blend is involved, 
            then the event will fire on the first frame of the blend</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.PostProcessingComponent">
            <summary>Support for opaque post-processing module</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBrain.sPostProcessingHandler">
            <summary>
            Because the PostProcessing package is not guaranteed to be present,
            we must handle PostFX in this opaque way.  This delegate will be called
            every frame (during LateUpdate) after the camera has been positioned.
            The intention is that the callback will make the right calls to the PostProcessing module.
            Cinemachine provides the CinemachinePostFX behaviour that makes use of this delegate.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.SoloCamera">
            <summary>
            API for the Unity Editor.
            Show this camera no matter what.  This is static, and so affects all Cinemachine brains.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.GetSoloGUIColor">
            <summary>API for the Unity Editor.</summary>
            <returns>Color used to indicate that a camera is in Solo mode.</returns>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.DefaultWorldUp">
            <summary>Get the default world up for the virtual cameras.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.GetOverrideFrame(System.Int32)">
            Get the override if it's present, else insert it
        </member>
        <member name="F:Cinemachine.CinemachineBrain.mOverrideBlendFromNothing">
            Get the next active blend on the stack.  Used when an override blends in from nothing.
        </member>
        <member name="M:Cinemachine.CinemachineBrain.GetActiveOverride">
            Get the first override that has a camera
        </member>
        <member name="M:Cinemachine.CinemachineBrain.SetCameraOverride(System.Int32,Cinemachine.ICinemachineCamera,Cinemachine.ICinemachineCamera,System.Single,System.Single)">
            <summary>
            This API is specifically for Timeline.  Do not use it.
            Override the current camera and current blend.  This setting will trump
            any in-game logic that sets virtual camera priorities and Enabled states.
            This is the main API for the timeline.
            </summary>
            <param name="overrideId">Id to represent a specific client.  An internal
            stack is maintained, with the most recent non-empty override taking precenence.
            This id must be > 0.  If you pass -1, a new id will be created, and returned.
            Use that id for subsequent calls.  Don't forget to
            call ReleaseCameraOverride after all overriding is finished, to
            free the OverideStack resources.</param>
            <param name="camA"> The camera to set, corresponding to weight=0</param>
            <param name="camB"> The camera to set, corresponding to weight=1</param>
            <param name="weightB">The blend weight.  0=camA, 1=camB</param>
            <param name="deltaTime">override for deltaTime.  Should be Time.FixedDelta for
            time-based calculations to be included, -1 otherwise</param>
            <returns>The oiverride ID.  Don't forget to call ReleaseCameraOverride
            after all overriding is finished, to free the OverideStack resources.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.ReleaseCameraOverride(System.Int32)">
            <summary>
            This API is specifically for Timeline.  Do not use it.
            Release the resources used for a camera override client.
            See SetCameraOverride.
            </summary>
            <param name="overrideId">The ID to released.  This is the value that
            was returned by SetCameraOverride</param>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.OnPreCull">
            This is only needed in editor mode to force timeline to call OnGUI while
            timeline is up and the game is not running, in order to allow dragging
            the composer guide in the game view.
        </member>
        <member name="P:Cinemachine.CinemachineBrain.IsBlending">
            <summary>
            Is there a blend in progress?
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.ActiveBlend">
            <summary>
            Get the current blend in progress.  Returns null if none.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.IsLive(Cinemachine.ICinemachineCamera)">
            <summary>
            True if the ICinemachineCamera the current active camera,
            or part of a current blend, either directly or indirectly because its parents are live.
            </summary>
            <param name="vcam">The camera to test whether it is live</param>
            <returns>True if the camera is live (directly or indirectly)
            or part of a blend in progress.</returns>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.ActiveVirtualCamera">
            <summary>
            Get the current active virtual camera.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBrain.CurrentCameraState">
            <summary>
            The current state applied to the unity camera (may be the result of a blend)
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.TopCameraFromPriorityQueue">
            <summary>
            Get the highest-priority Enabled ICinemachineCamera
            that is visible to my camera.  Culling Mask is used to test visibility.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.LookupBlendCurve(Cinemachine.ICinemachineCamera,Cinemachine.ICinemachineCamera,System.Single@)">
            <summary>
            Create a blend curve for blending from one ICinemachineCamera to another.
            If there is a specific blend defined for these cameras it will be used, otherwise
            a default blend will be created, which could be a cut.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.CreateBlend(Cinemachine.ICinemachineCamera,Cinemachine.ICinemachineCamera,UnityEngine.AnimationCurve,System.Single,Cinemachine.CinemachineBlend)">
            <summary>
            Create a blend from one ICinemachineCamera to another,
            or to/from a point, if we can't do anything else
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.PushStateToUnityCamera(Cinemachine.CameraState,Cinemachine.ICinemachineCamera)">
            <summary> Apply a cref="CameraState"/> to the game object</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBrain.GetSubframeCount">
            <summary>API for CinemachineCore only: Get the number of subframes to
            update the virtual cameras.</summary>
            <returns>Number of subframes registered by the first brain's FixedUpdate</returns>
        </member>
        <member name="T:Cinemachine.StaticPointVirtualCamera">
            <summary>
            Point source for blending. It's not really a virtual camera, but takes
            a CameraState and exposes it as a virtual camera for the purposes of blending.
            </summary>
        </member>
        <member name="T:Cinemachine.BlendSourceVirtualCamera">
            <summary>
            Blend result source for blending.   This exposes a CinemachineBlend object
            as an ersatz virtual camera for the purposes of blending.  This achieves the purpose
            of blending the result oif a blend.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineClearShot">
            <summary>
            Cinemachine ClearShot is a "manager camera" that owns and manages a set of 
            Virtual Camera gameObject children.  When Live, the ClearShot will check the
            children, and choose the one with the best quality shot and make it Live.
            
            This can be a very powerful tool.  If the child cameras have CinemachineCollider 
            extensions, they will analyze the scene for target obstructions, optimal target
            distance, and other items, and report their assessment of shot quality back to 
            the ClearShot parent, who will then choose the best one.  You can use this to set
            up complex multi-camera coverage of a scene, and be assured that a clear shot of 
            the target will always be available.
            
            If multiple child cameras have the same shot quality, the one with the highest 
            priority will be chosen.
            
            You can also define custom blends between the ClearShot children.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_LookAt">
            <summary>Default object for the camera children to look at (the aim target), if not specified in a child camera.  May be empty.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_Follow">
            <summary>Default object for the camera children wants to move with (the body target), if not specified in a child camera.  May be empty.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_ShowDebugText">
            <summary>When enabled, the current camera and blend will be indicated in the game window, for debugging</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_ChildCameras">
            <summary>Internal API for the editor.  Do not use this filed.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_ActivateAfter">
            <summary>Wait this many seconds before activating a new child camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_MinDuration">
            <summary>An active camera must be active for at least this many seconds</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_RandomizeChoice">
            <summary>If checked, camera choice will be randomized if multiple cameras are equally desirable.  Otherwise, child list order will be used</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_DefaultBlend">
            <summary>The blend which is used if you don't explicitly define a blend between two Virtual Cameras</summary>
        </member>
        <member name="F:Cinemachine.CinemachineClearShot.m_CustomBlends">
            <summary>This is the asset which contains custom settings for specific blends</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.Description">
            <summary>Gets a brief debug description of this virtual camera, for use when displayiong debug info</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.LiveChild">
            <summary>Get the current "best" child virtual camera, that would be chosen
            if the ClearShot camera were active.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.State">
            <summary>The CameraState of the currently live child</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.LiveChildOrSelf">
            <summary>Return the live child.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.LookAt">
            <summary>Get the current LookAt target.  Returns parent's LookAt if parent
            is non-null and no specific LookAt defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.Follow">
            <summary>Get the current Follow target.  Returns parent's Follow if parent
            is non-null and no specific Follow defined for this camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  This implementation
            updates all the children, chooses the best one, and implements any required blending.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.OnEnable">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.OnTransformChildrenChanged">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.OnGUI">
            <summary>Displays the current active camera on the game screen, if requested</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.IsBlending">
            <summary>Is there a blend in progress?</summary>
        </member>
        <member name="P:Cinemachine.CinemachineClearShot.ChildCameras">
            <summary>The list of child cameras.  These are just the immediate children in the hierarchy.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.ResetRandomization">
            <summary>If RandomizeChoice is enabled, call this to re-randomize the children next frame.
            This is useful if you want to freshen up the shot.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineClearShot.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>Notification that this virtual camera is going live.
            This implementation resets the child randomization.</summary>
            <param name="fromCam">The camera being deactivated.  May be null.</param>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="T:Cinemachine.CinemachineCollider">
            <summary>
            An add-on module for Cinemachine Virtual Camera that post-processes
            the final position of the virtual camera. Based on the supplied settings,
            the Collider will attempt to preserve the line of sight
            with the LookAt target of the virtual camera by moving 
            away from objects that will obstruct the view.
            
            Additionally, the Collider can be used to assess the shot quality and 
            report this as a field in the camera State.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_CollideAgainst">
            <summary>The Unity layer mask against which the collider will raycast.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_IgnoreTag">
            <summary>Obstacles with this tag will be ignored.  It is a good idea to set this field to the target's tag</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_MinimumDistanceFromTarget">
            <summary>Obstacles closer to the target than this will be ignored</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_AvoidObstacles">
            <summary>
            When enabled, will attempt to resolve situations where the line of sight to the 
            target is blocked by an obstacle
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_DistanceLimit">
            <summary>
            The raycast distance to test for when checking if the line of sight to this camera's target is clear.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_CameraRadius">
            <summary>
            Camera will try to maintain this distance from any obstacle.  
            Increase this value if you are seeing inside obstacles due to a large 
            FOV on the camera.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineCollider.ResolutionStrategy">
            <summary>The way in which the Collider will attempt to preserve sight of the target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.ResolutionStrategy.PullCameraForward">
            <summary>Camera will be pulled forward along its Z axis until it is in front of 
            the nearest obstacle</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.ResolutionStrategy.PreserveCameraHeight">
            <summary>In addition to pulling the camera forward, an effort will be made to 
            return the camera to its original height</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.ResolutionStrategy.PreserveCameraDistance">
            <summary>In addition to pulling the camera forward, an effort will be made to 
            return the camera to its original distance from the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_Strategy">
            <summary>The way in which the Collider will attempt to preserve sight of the target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_MaximumEffort">
            <summary>
            Upper limit on how many obstacle hits to process.  Higher numbers may impact performance.  
            In most environments, 4 is enough.  
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_Damping">
            <summary>
            The gradualness of collision resolution.  Higher numbers will move the 
            camera more gradually away from obstructions.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.m_OptimalTargetDistance">
            <summary>If greater than zero, a higher score will be given to shots when the target is closer to
            this distance.  Set this to zero to disable this feature</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCollider.IsTargetObscured(Cinemachine.ICinemachineCamera)">
            <summary>See wheter an object is blocking the camera's view of the target</summary>
            <param name="vcam">The virtual camera in question.  This might be different from the
            virtual camera that owns the collider, in the event that the camera has children</param>
            <returns>True if something is blocking the view</returns>
        </member>
        <member name="M:Cinemachine.CinemachineCollider.CameraWasDisplaced(Cinemachine.CinemachineVirtualCameraBase)">
            <summary>See whether the virtual camera has been moved nby the collider</summary>
            <param name="vcam">The virtual camera in question.  This might be different from the
            virtual camera that owns the collider, in the event that the camera has children</param>
            <returns>True if the virtual camera has been displaced due to collision or
            target obstruction</returns>
        </member>
        <member name="M:Cinemachine.CinemachineCollider.OnDestroy">
            <summary>Cleanup</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCollider.PrecisionSlush">
            This must be small but greater than 0 - reduces false results due to precision
        </member>
        <member name="P:Cinemachine.CinemachineCollider.DebugPaths">
            <summary>Inspector API for debugging collision resolution path</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCollider.PostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>Callcack to to the collision resolution and shot evaluation</summary>
        </member>
        <member name="T:Cinemachine.CinemachineConfiner">
            <summary>
            An add-on module for Cinemachine Virtual Camera that post-processes
            the final position of the virtual camera. It will confine the virtual
            camera's position to the volume specified in the Bounding Volume field.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineConfiner.Mode">
            <summary>The confiner can operate using a 2D bounding shape or a 3D bounding volume</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_ConfineMode">
            <summary>The confiner can operate using a 2D bounding shape or a 3D bounding volume</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_BoundingVolume">
            <summary>The volume within which the camera is to be contained.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_BoundingShape2D">
            <summary>The 2D shape within which the camera is to be contained.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_ConfineScreenEdges">
            <summary>If camera is orthographic, screen edges will be confined to the volume.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineConfiner.m_Damping">
            <summary>How gradually to return the camera to the bounding volume if it goes beyond the borders</summary>
        </member>
        <member name="M:Cinemachine.CinemachineConfiner.CameraWasDisplaced(Cinemachine.CinemachineVirtualCameraBase)">
            <summary>See whether the virtual camera has been moved by the confiner</summary>
            <param name="vcam">The virtual camera in question.  This might be different from the
            virtual camera that owns the confiner, in the event that the camera has children</param>
            <returns>True if the virtual camera has been repositioned</returns>
        </member>
        <member name="P:Cinemachine.CinemachineConfiner.IsValid">
            <summary>Check if the bounding volume is defined</summary>
        </member>
        <member name="M:Cinemachine.CinemachineConfiner.PostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>Callback to to the camera confining</summary>
        </member>
        <member name="M:Cinemachine.CinemachineConfiner.InvalidatePathCache">
            <summary>Call this if the bounding shape's points change at runtime</summary>
        </member>
        <member name="T:Cinemachine.CinemachineDollyCart">
            <summary>
            This is a very simple behaviour that constrains its transform to a CinemachinePath.  
            It can be used to animate any objects along a path, or as a Follow target for 
            Cinemachine Virtual Cameras.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_Path">
            <summary>The path to follow</summary>
        </member>
        <member name="T:Cinemachine.CinemachineDollyCart.UpdateMethod">
            <summary>This enum defines the options available for the update method.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.UpdateMethod.Update">
            <summary>Updated in normal MonoBehaviour Update.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.UpdateMethod.FixedUpdate">
            <summary>Updated in sync with the Physics module, in FixedUpdate</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_UpdateMethod">
            <summary>When to move the cart, if Velocity is non-zero</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_PositionUnits">
            <summary>How to interpret the Path Position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_Speed">
            <summary>Move the cart with this speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineDollyCart.m_Position">
            <summary>The cart's current position on the path, in distance units</summary>
        </member>
        <member name="T:Cinemachine.CinemachineExternalCamera">
            <summary>
            This component will expose a non-cinemachine camera to the cinemachine system,
            allowing it to participate in blends.
            Just add it as a component alongside an existing Unity Camera component.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineExternalCamera.m_LookAt">
            <summary>The object that the camera is looking at.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineExternalCamera.State">
            <summary>Get the CameraState, as we are able to construct one from the Unity Camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineExternalCamera.LookAt">
            <summary>The object that the camera is looking at</summary>
        </member>
        <member name="P:Cinemachine.CinemachineExternalCamera.Follow">
            <summary>This vcam defines no targets</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExternalCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Construct a CameraState object from the Unity Camera</summary>
        </member>
        <member name="T:Cinemachine.CinemachineFollowZoom">
            <summary>
            An add-on module for Cinemachine Virtual Camera that adjusts
            the FOV of the lens to keep the target object at a constant size on the screen,
            regardless of camera and target position.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFollowZoom.m_Width">
            <summary>The shot width to maintain, in world units, at target distance.
            FOV will be adusted as far as possible to maintain this width at the
            target distance from the camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFollowZoom.m_Damping">
            <summary>Increase this value to soften the aggressiveness of the follow-zoom.
            Small numbers are more responsive, larger numbers give a more heavy slowly responding camera. </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFollowZoom.m_MinFOV">
            <summary>Will not generate an FOV smaller than this.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFollowZoom.m_MaxFOV">
            <summary>Will not generate an FOV larget than this.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFollowZoom.PostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>Callback to preform the zoom adjustment</summary>
        </member>
        <member name="T:Cinemachine.CinemachineFreeLook">
            <summary>
            A Cinemachine Camera geared towards a 3rd person camera experience.
            The camera orbits around its subject with three separate camera rigs defining
            rings around the target. Each rig has its own radius, height offset, composer,
            and lens settings.
            Depending on the camera's position along the spline connecting these three rigs,
            these settings are interpolated to give the final camera position and state.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_LookAt">
            <summary>Object for the camera children to look at (the aim target)</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Follow">
            <summary>Object for the camera children wants to move with (the body target)</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_CommonLens">
            <summary>If enabled, this lens setting will apply to all three child rigs, otherwise the child rig lens settings will be used</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Lens">
            <summary>Specifies the lens properties of this Virtual Camera.  
            This generally mirrors the Unity Camera's lens settings, and will be used to drive 
            the Unity camera when the vcam is active</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_YAxis">
            <summary>The Vertical axis.  Value is 0..1.  Chooses how to blend the child rigs</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_XAxis">
            <summary>The Horizontal axis.  Value is 0..359.  This is passed on to the rigs' OrbitalTransposer component</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Heading">
            <summary>The definition of Forward.  Camera will follow behind</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_RecenterToTargetHeading">
            <summary>Controls how automatic recentering of the X axis is accomplished</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_BindingMode">
            <summary>The coordinate space to use when interpreting the offset from the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_SplineCurvature">
            <summary></summary>
        </member>
        <member name="T:Cinemachine.CinemachineFreeLook.Orbit">
            <summary>Defines the height and radius of the Rig orbit</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.Orbit.m_Height">
            <summary>Height relative to target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.Orbit.m_Radius">
            <summary>Radius of orbit</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.Orbit.#ctor(System.Single,System.Single)">
            <summary>Constructor with specific values</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Orbits">
            <summary>The radius and height of the three orbiting rigs</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnValidate">
            <summary>Enforce bounds for fields, when changed in inspector.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.GetRig(System.Int32)">
            <summary>Get a child rig</summary>
            <param name="i">Rig index.  Can be 0, 1, or 2</param>
            <returns>The rig, or null if index is bad.</returns>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.RigNames">
            <summary>Names of the 3 child rigs</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnEnable">
            <summary>Updates the child rig cache</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnDestroy">
            <summary>Makes sure that the child rigs get destroyed in an undo-firndly manner.
            Invalidates the rig cache.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnTransformChildrenChanged">
            <summary>Invalidates the rig cache</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.State">
            <summary>The cacmera state, which will be a blend of the child rig states</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.LookAt">
            <summary>Get the current LookAt target.  Returns parent's LookAt if parent
            is non-null and no specific LookAt defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.Follow">
            <summary>Get the current Follow target.  Returns parent's Follow if parent
            is non-null and no specific Follow defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFreeLook.LiveChildOrSelf">
            <summary>Returns the rig with the greatest weight</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.  
            Returns true if the child is currently contributing actively to the camera state.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  All 3 child rigs are updated,
            and a blend calculated, depending on the value of the Y axis.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>If we are transitioning from another FreeLook, grab the axis values from it.</summary>
            <param name="fromCam">The camera being deactivated.  May be null.</param>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.m_Rigs">
            Serialized in order to support copy/paste
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.CreateRigOverride">
            <summary>
            Override component pipeline creation.
            This needs to be done by the editor to support Undo.
            The override must do exactly the same thing as the CreatePipeline method in this class.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineFreeLook.CreateRigDelegate">
            <summary>
            Override component pipeline creation.
            This needs to be done by the editor to support Undo.
            The override must do exactly the same thing as the CreatePipeline method in this class.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFreeLook.DestroyRigOverride">
            <summary>
            Override component pipeline destruction.
            This needs to be done by the editor to support Undo.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineFreeLook.DestroyRigDelegate">
            <summary>
            Override component pipeline destruction.
            This needs to be done by the editor to support Undo.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineFreeLook.GetLocalPositionForCameraFromInput(System.Single)">
            <summary>
            Returns the local position of the camera along the spline used to connect the
            three camera rigs. Does not take into account the current heading of the
            camera (or its target)
            </summary>
            <param name="t">The t-value for the camera on its spline. Internally clamped to
            the value [0,1]</param>
            <returns>The local offset (back + up) of the camera WRT its target based on the
            supplied t-value</returns>
        </member>
        <member name="T:Cinemachine.CinemachineMixingCamera">
            <summary>
            CinemachineMixingCamera is a "manager camera" that takes on the state of 
            the weighted average of the states of its child virtual cameras.
            
            A fixed number of slots are made available for cameras, rather than a dynamic array.  
            We do it this way in order to support weight animation from the Timeline.
            Timeline cannot animate array elements.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.MaxCameras">
            <summary>The maximum number of tracked cameras.  If you want to add 
            more cameras, do it here in the source code, and be sure to add the 
            extra member variables and to make the appropriate changes in 
            GetWeight() and SetWeight().
            The inspector will figure itself out based on this value.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight0">
            <summary>Weight of the first tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight1">
            <summary>Weight of the second tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight2">
            <summary>Weight of the third tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight3">
            <summary>Weight of the fourth tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight4">
            <summary>Weight of the fifth tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight5">
            <summary>Weight of the sixth tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight6">
            <summary>Weight of the seventh tracked camera</summary>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_Weight7">
            <summary>Weight of the eighth tracked camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.GetWeight(System.Int32)">
            <summary>Get the weight of the child at an index.</summary>
            <param name="index">The child index. Only immediate CinemachineVirtualCameraBase 
            children are counted.</param>
            <returns>The weight of the camera.  Valid only if camera is active and enabled.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.SetWeight(System.Int32,System.Single)">
            <summary>Set the weight of the child at an index.</summary>
            <param name="index">The child index. Only immediate CinemachineVirtualCameraBase 
            children are counted.</param>
            <param name="w">The weight to set.  Can be any non-negative number.</param>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.GetWeight(Cinemachine.CinemachineVirtualCameraBase)">
            <summary>Get the weight of the child CinemachineVirtualCameraBase.</summary>
            <param name="vcam">The child camera.</param>
            <returns>The weight of the camera.  Valid only if camera is active and enabled.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.SetWeight(Cinemachine.CinemachineVirtualCameraBase,System.Single)">
            <summary>Set the weight of the child CinemachineVirtualCameraBase.</summary>
            <param name="vcam">The child camera.</param>
            <param name="w">The weight to set.  Can be any non-negative number.</param>
        </member>
        <member name="F:Cinemachine.CinemachineMixingCamera.m_State">
            <summary>Blended camera state</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.LiveChild">
            <summary>Get the current "best" child virtual camera, which is nominally 
            the one with the greatest weight.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.State">
            <summary>The blended CameraState</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.LookAt">
            <summary>Not used</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.Follow">
            <summary>Not used</summary>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.LiveChildOrSelf">
            <summary>Return the live child.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.OnEnable">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.OnTransformChildrenChanged">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.OnValidate">
            <summary>Makes sure the weights are non-negative</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineMixingCamera.ChildCameras">
            <summary>Get the cached list of child cameras.  
            These are just the immediate children in the hierarchy.
            Note: only the first entries of this list participate in the 
            final blend, up to MaxCameras</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.InvalidateListOfChildren">
            <summary>Invalidate the cached list of child cameras.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.ValidateListOfChildren">
            <summary>Rebuild the cached list of child cameras.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineMixingCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  This implementation
            computes and caches the weighted blend of the tracked cameras.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="T:Cinemachine.CinemachinePath">
            <summary>Defines a world-space path, consisting of an array of waypoints,
            each of which has position, tangent, and roll settings.  Bezier interpolation
            is performed between the waypoints, to get a smooth and continuous path.</summary>
        </member>
        <member name="T:Cinemachine.CinemachinePath.Waypoint">
            <summary>A waypoint along the path</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.Waypoint.position">
            <summary>Position in path-local space</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.Waypoint.tangent">
            <summary>Offset from the position, which defines the tangent of the curve at the waypoint.  
            The length of the tangent encodes the strength of the bezier handle.  
            The same handle is used symmetrically on both sides of the waypoint, to ensure smoothness.</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.Waypoint.roll">
            <summary>Defines the roll of the path at this waypoint.  
            The other orientation axes are inferred from the tangent and world up.</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.m_Looped">
            <summary>If checked, then the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePath.m_Waypoints">
            <summary>The waypoints that define the path.
            They will be interpolated using a bezier curve</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePath.MinPos">
            <summary>The minimum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePath.MaxPos">
            <summary>The maximum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePath.Looped">
            <summary>True if the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePath.DistanceCacheSampleStepsPerSegment">
            <summary>When calculating the distance cache, sample the path this many 
            times between points</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePath.GetBoundingIndices(System.Single,System.Int32@,System.Int32@)">
            <summary>Returns normalized position</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePath.EvaluatePosition(System.Single)">
            <summary>Get a worldspace position of a point along the path</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space position of the point along at path at pos</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePath.EvaluateTangent(System.Single)">
            <summary>Get the tangent of the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space direction of the path tangent.
            Length of the vector represents the tangent strength</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePath.EvaluateOrientation(System.Single)">
            <summary>Get the orientation the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space orientation of the path, as defined by tangent, up, and roll.</returns>
        </member>
        <member name="T:Cinemachine.CinemachinePipeline">
            <summary>
            Internal container for CinemachineComponentBase.  Does nothing but contain.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineSmoothPath">
            <summary>Defines a world-space path, consisting of an array of waypoints,
            each of which has position and roll settings.  Bezier interpolation
            is performed between the waypoints, to get a smooth and continuous path.
            The path will pass through all waypoints, and (unlike CinemachinePath) first 
            and second order continuity is guaranteed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineSmoothPath.m_Looped">
            <summary>If checked, then the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="T:Cinemachine.CinemachineSmoothPath.Waypoint">
            <summary>A waypoint along the path</summary>
        </member>
        <member name="F:Cinemachine.CinemachineSmoothPath.Waypoint.position">
            <summary>Position in path-local space</summary>
        </member>
        <member name="F:Cinemachine.CinemachineSmoothPath.Waypoint.roll">
            <summary>Defines the roll of the path at this waypoint.  
            The other orientation axes are inferred from the tangent and world up.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.Waypoint.AsVector4">
            <summary>Representation as Vector4</summary>
        </member>
        <member name="F:Cinemachine.CinemachineSmoothPath.m_Waypoints">
            <summary>The waypoints that define the path.
            They will be interpolated using a bezier curve</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.MinPos">
            <summary>The minimum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.MaxPos">
            <summary>The maximum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.Looped">
            <summary>True if the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSmoothPath.DistanceCacheSampleStepsPerSegment">
            <summary>When calculating the distance cache, sample the path this many 
            times between points</summary>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.InvalidateDistanceCache">
            <summary>Call this if the path changes in such a way as to affect distances
            or other cached path elements</summary>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.GetBoundingIndices(System.Single,System.Int32@,System.Int32@)">
            <summary>Returns normalized position</summary>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.EvaluatePosition(System.Single)">
            <summary>Get a worldspace position of a point along the path</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space position of the point along at path at pos</returns>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.EvaluateTangent(System.Single)">
            <summary>Get the tangent of the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space direction of the path tangent.
            Length of the vector represents the tangent strength</returns>
        </member>
        <member name="M:Cinemachine.CinemachineSmoothPath.EvaluateOrientation(System.Single)">
            <summary>Get the orientation the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space orientation of the path, as defined by tangent, up, and roll.</returns>
        </member>
        <member name="T:Cinemachine.CinemachineStateDrivenCamera">
            <summary>
            This is a virtual camera "manager" that owns and manages a collection
            of child Virtual Cameras.  These child vcams are mapped to individual states in
            an animation state machine, allowing you to associate specific vcams to specific 
            animation states.  When that state is active in the state machine, then the 
            associated camera will be activated.
            
            You can define custom blends and transitions between child cameras.
            
            In order to use this behaviour, you must have an animated target (i.e. an object
            animated with a state machine) to drive the behaviour.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_LookAt">
            <summary>Default object for the camera children to look at (the aim target), if not specified in a child rig.  May be empty</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_Follow">
            <summary>Default object for the camera children wants to move with (the body target), if not specified in a child rig.  May be empty</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_AnimatedTarget">
            <summary>The state machine whose state changes will drive this camera's choice of active child</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_LayerIndex">
            <summary>Which layer in the target FSM to observe</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_ShowDebugText">
            <summary>When enabled, the current camera and blend will be indicated in the game window, for debugging</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_EnableAllChildCameras">
            <summary>Force all child cameras to be enabled.  This is useful if animating them in Timeline, but consumes extra resources.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_ChildCameras">
            <summary>Internal API for the editor.  Do not use this field</summary>
        </member>
        <member name="T:Cinemachine.CinemachineStateDrivenCamera.Instruction">
            <summary>This represents a single instrunction to the StateDrivenCamera.  It associates
            an state from the state machine with a child Virtual Camera, and also holds
            activation tuning parameters.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.Instruction.m_FullHash">
            <summary>The full hash of the animation state</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.Instruction.m_VirtualCamera">
            <summary>The virtual camera to activate whrn the animation state becomes active</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.Instruction.m_ActivateAfter">
            <summary>How long to wait (in seconds) before activating the virtual camera. 
            This filters out very short state durations</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.Instruction.m_MinDuration">
            <summary>The minimum length of time (in seconds) to keep a virtual camera active</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_Instructions">
            <summary>The set of instructions associating virtual cameras with states.  
            These instructions are used to choose the live child at any given moment</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_DefaultBlend">
            <summary>
            The blend which is used if you don't explicitly define a blend between two Virtual Camera children.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_CustomBlends">
            <summary>
            This is the asset which contains custom settings for specific child blends.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineStateDrivenCamera.ParentHash">
            <summary>Internal API for the Inspector editor.  This implements nested states.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.ParentHash.m_Hash">
            <summary>Internal API for the Inspector editor</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.ParentHash.m_ParentHash">
            <summary>Internal API for the Inspector editor</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.ParentHash.#ctor(System.Int32,System.Int32)">
            <summary>Internal API for the Inspector editor</summary>
        </member>
        <member name="F:Cinemachine.CinemachineStateDrivenCamera.m_ParentHash">
            <summary>Internal API for the Inspector editor</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.Description">
            <summary>Gets a brief debug description of this virtual camera, for use when displayiong debug info</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.LiveChild">
            <summary>Get the current "best" child virtual camera, that would be chosen
            if the State Driven Camera were active.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.LiveChildOrSelf">
            <summary>Return the live child.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.State">
            <summary>The State of the current live child</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.LookAt">
            <summary>Get the current LookAt target.  Returns parent's LookAt if parent
            is non-null and no specific LookAt defined for this camera</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.Follow">
            <summary>Get the current Follow target.  Returns parent's Follow if parent
            is non-null and no specific Follow defined for this camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.
            Make sure it is removed from all the children.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  This implementation
            updates all the children, chooses the best one, and implements any required blending.</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.OnEnable">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.OnTransformChildrenChanged">
            <summary>Makes sure the internal child cache is up to date</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.OnGUI">
            <summary>Displays the current active camera on the game screen, if requested</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.ChildCameras">
            <summary>The list of child cameras.  These are just the immediate children in the hierarchy.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineStateDrivenCamera.IsBlending">
            <summary>Is there a blend in progress?</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.CreateFakeHashName(System.Int32,System.String)">
            <summary>API for the inspector editor.  Animation module does not have hashes
            for state parents, so we have to invent them in order to implement nested state
            handling</summary>
        </member>
        <member name="M:Cinemachine.CinemachineStateDrivenCamera.ValidateInstructions">
            <summary>Internal API for the inspector editor.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup">
            <summary>Defines a group of target objects, each with a radius and a weight.
            The weight is used when calculating the average position of the target group.
            Higher-weighted members of the group will count more.
            The bounding box is calculated by taking the member positions, weight, 
            and radii into account.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup.Target">
            <summary>Holds the information that represents a member of the group</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.Target.target">
            <summary>The target objects.  This object's position and orientation will contribute to the 
            group's average position and orientation, in accordance with its weight</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.Target.weight">
            <summary>How much weight to give the target when averaging.  Cannot be negative</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.Target.radius">
            <summary>The radius of the target, used for calculating the bounding box.  Cannot be negative</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup.PositionMode">
            <summary>How the group's position is calculated</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.PositionMode.GroupCenter">
            <summary>Group position will be the center of the group's axis-aligned bounding box</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.PositionMode.GroupAverage">
            <summary>Group position will be the weighted average of the positions of the members</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_PositionMode">
            <summary>How the group's position is calculated</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup.RotationMode">
            <summary>How the group's orientation is calculated</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.RotationMode.Manual">
            <summary>Manually set in the group's transform</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.RotationMode.GroupAverage">
            <summary>Weighted average of the orientation of its members.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_RotationMode">
            <summary>How the group's orientation is calculated</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTargetGroup.UpdateMethod">
            <summary>This enum defines the options available for the update method.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.UpdateMethod.Update">
            <summary>Updated in normal MonoBehaviour Update.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.UpdateMethod.FixedUpdate">
            <summary>Updated in sync with the Physics module, in FixedUpdate</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.UpdateMethod.LateUpdate">
            <summary>Updated in MonoBehaviour LateUpdate.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_UpdateMethod">
            <summary>When to update the group's transform based on the position of the group members</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_Targets">
            <summary>The target objects, together with their weights and radii, that will
            contribute to the group's average position, orientation, and size</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTargetGroup.m_lastRadius">
            Cache of the last valid radius
        </member>
        <member name="P:Cinemachine.CinemachineTargetGroup.BoundingBox">
            <summary>The axis-aligned bounding box of the group, computed using the
            targets positions and radii</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTargetGroup.IsEmpty">
            <summary>Return true if there are no members with weight > 0</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTargetGroup.GetViewSpaceBoundingBox(UnityEngine.Matrix4x4)">
            <summary>The axis-aligned bounding box of the group, in a specific reference frame</summary>
            <param name="mView">The frame of reference in which to compute the bounding box</param>
            <returns>The axis-aligned bounding box of the group, in the desired frame of reference</returns>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCamera">
             <summary>
             This behaviour is intended to be attached to an empty Transform GameObject, 
             and it represents a Virtual Camera within the Unity scene.
             
             The Virtual Camera will animate its Transform according to the rules contained
             in its CinemachineComponent pipeline (Aim, Body, and Noise).  When the virtual
             camera is Live, the Unity camera will assume the position and orientation
             of the virtual camera.
             
             A virtual camera is not a camera. Instead, it can be thought of as a camera controller,
             not unlike a cameraman. It can drive the Unity Camera and control its position, 
             orientation, lens settings, and PostProcessing effects. Each Virtual Camera owns 
             its own Cinemachine Component Pipeline, through which you provide the instructions 
             for dynamically tracking specific game objects. 
             
             A virtual camera is very lightweight, and does no rendering of its own. It merely 
             tracks interesting GameObjects, and positions itself accordingly. A typical game 
             can have dozens of virtual cameras, each set up to follow a particular character 
             or capture a particular event. 
             
             A Virtual Camera can be in any of three states: 
             
             * **Live**: The virtual camera is actively controlling the Unity Camera. The 
             virtual camera is tracking its targets and being updated every frame. 
             * **Standby**: The virtual camera is tracking its targets and being updated 
             every frame, but no Unity Camera is actively being controlled by it. This is 
             the state of a virtual camera that is enabled in the scene but perhaps at a 
             lower priority than the Live virtual camera. 
             * **Disabled**: The virtual camera is present but disabled in the scene. It is 
             not actively tracking its targets and so consumes no processing power. However, 
             the virtual camera can be made live from the Timeline. 
             
             The Unity Camera can be driven by any virtual camera in the scene. The game 
             logic can choose the virtual camera to make live by manipulating the virtual 
             cameras' enabled flags and their priorities, based on game logic. 
            
             In order to be driven by a virtual camera, the Unity Camera must have a CinemachineBrain 
             behaviour, which will select the most eligible virtual camera based on its priority 
             or on other criteria, and will manage blending. 
             </summary>
             <seealso cref="T:Cinemachine.CinemachineVirtualCameraBase"/>
             <seealso cref="T:Cinemachine.LensSettings"/>
             <seealso cref="T:Cinemachine.CinemachineComposer"/>
             <seealso cref="T:Cinemachine.CinemachineTransposer"/>
             <seealso cref="T:Cinemachine.CinemachineBasicMultiChannelPerlin"/>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.m_LookAt">
            <summary>The object that the camera wants to look at (the Aim target).
            The Aim component of the CinemachineComponent pipeline
            will refer to this target and orient the vcam in accordance with rules and
            settings that are provided to it.
            If this is null, then the vcam's Transform orientation will be used.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.m_Follow">
            <summary>The object that the camera wants to move with (the Body target).
            The Body component of the CinemachineComponent pipeline
            will refer to this target and position the vcam in accordance with rules and
            settings that are provided to it.
            If this is null, then the vcam's Transform position will be used.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.m_Lens">
            <summary>Specifies the LensSettings of this Virtual Camera.
            These settings will be transferred to the Unity camera when the vcam is live.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.PipelineName">
            <summary>This is the name of the hidden GameObject that will be created as a child object
            of the virtual camera.  This hidden game object acts as a container for the polymorphic
            CinemachineComponent pipeline.  The Inspector UI for the Virtual Camera
            provides access to this pipleline, as do the CinemachineComponent-family of
            public methods in this class.
            The lifecycle of the pipeline GameObject is managed automatically.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCamera.State">
            <summary>The CameraState object holds all of the information
            necessary to position the Unity camera.  It is the output of this class.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCamera.LookAt">
            <summary>Get the LookAt target for the Aim component in the CinemachinePipeline.
            If this vcam is a part of a meta-camera collection, then the owner's target
            will be used if the local target is null.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCamera.Follow">
            <summary>Get the Follow target for the Body component in the CinemachinePipeline.
            If this vcam is a part of a meta-camera collection, then the owner's target
            will be used if the local target is null.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at LateUpdate time
            so the vcam can position itself and track its targets.  This class will
            invoke its pipeline and generate a CameraState for this frame.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.OnEnable">
            <summary>Make sure that the pipeline cache is up-to-date.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.OnDestroy">
            <summary>Calls the DestroyPipelineDelegate for destroying the hidden
            child object, to support undo.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.OnValidate">
            <summary>Enforce bounds for fields, when changed in inspector.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.CreatePipelineOverride">
            <summary>
            Override component pipeline creation.
            This needs to be done by the editor to support Undo.
            The override must do exactly the same thing as the CreatePipeline method in this class.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCamera.CreatePipelineDelegate">
            <summary>
            Override component pipeline creation.
            This needs to be done by the editor to support Undo.
            The override must do exactly the same thing as the CreatePipeline method in
            the CinemachineVirtualCamera class.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCamera.DestroyPipelineOverride">
            <summary>
            Override component pipeline destruction.
            This needs to be done by the editor to support Undo.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCamera.DestroyPipelineDelegate">
            <summary>
            Override component pipeline destruction.
            This needs to be done by the editor to support Undo.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.DestroyPipeline">
            <summary>Destroy any existing pipeline container.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.CreatePipeline(Cinemachine.CinemachineVirtualCamera)">
            <summary>Create a default pipeline container.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.InvalidateComponentPipeline">
            <summary>
            Editor API: Call this when changing the pipeline from the editor.
            Will force a rebuild of the pipeline cache.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.GetComponentOwner">
            <summary>Get the hidden CinemachinePipeline child object.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.GetComponentPipeline">
            <summary>Get the component pipeline owned by the hidden child pipline container.
            For most purposes, it is preferable to use the GetCinemachineComponent method.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.GetCinemachineComponent(Cinemachine.CinemachineCore.Stage)">
            <summary>Get the component set for a specific stage.</summary>
            <param name="stage">The stage for which we want the component</param>
            <returns>The Cinemachine component for that stage, or null if not defined</returns>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.GetCinemachineComponent``1">
            <summary>Get an existing component of a specific type from the cinemachine pipeline.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.AddCinemachineComponent``1">
            <summary>Add a component to the cinemachine pipeline.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.DestroyCinemachineComponent``1">
            <summary>Remove a component from the cinemachine pipeline.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCamera.UserIsDragging">
            <summary>API for the editor, to make the dragging of position handles behave better.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCamera.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBasicMultiChannelPerlin">
            <summary>
            As a part of the Cinemachine Pipeline implementing the Noise stage, this
            component adds Perlin Noise to the Camera state, in the Correction
            channel of the CameraState.
            
            The noise is created by using a predefined noise profile asset.  This defines the 
            shape of the noise over time.  You can scale this in amplitude or in time, to produce
            a large family of different noises using the same profile.
            </summary>
            <seealso cref="T:Cinemachine.NoiseSettings"/>
        </member>
        <member name="F:Cinemachine.CinemachineBasicMultiChannelPerlin.m_NoiseProfile">
            <summary>
            Serialized property for referencing a NoiseSettings asset
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBasicMultiChannelPerlin.m_AmplitudeGain">
            <summary>
            Gain to apply to the amplitudes defined in the settings asset.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBasicMultiChannelPerlin.m_FrequencyGain">
            <summary>
            Scale factor to apply to the frequencies defined in the settings asset.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBasicMultiChannelPerlin.IsValid">
            <summary>True if the component is valid, i.e. it has a noise definition and is enabled.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBasicMultiChannelPerlin.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Noise stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBasicMultiChannelPerlin.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies noise to the Correction channel of the CameraState if the
            delta time is greater than 0.  Otherwise, does nothing.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">How much to advance the perlin noise generator.
            Noise is only applied if this value is greater than or equal to 0</param>
        </member>
        <member name="T:Cinemachine.CinemachineComposer">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera at the vcam's LookAt target object, with 
            configurable offsets, damping, and composition rules.
            
            The composer does not change the camera's position.  It will only pan and tilt the 
            camera where it is, in order to get the desired framing.  To move the camera, you have
            to use the virtual camera's Body section.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.OnGUICallback">
            <summary>Used by the Inspector Editor to display on-screen guides.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_TrackedObjectOffset">
            <summary>Target offset from the object's center in LOCAL space which
            the Composer tracks. Use this to fine-tune the tracking target position
            when the desired area is not in the tracked object's center</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_LookaheadTime">
            <summary>This setting will instruct the composer to adjust its target offset based
            on the motion of the target.  The composer will look at a point where it estimates
            the target will be this many seconds into the future.  Note that this setting is sensitive
            to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.
            If the camera jitters unacceptably when the target is in motion, turn down this setting, 
            or animate the target more smoothly.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_LookaheadSmoothing">
            <summary>Controls the smoothness of the lookahead algorithm.  Larger values smooth out 
            jittery predictions and also increase prediction lag</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_HorizontalDamping">
            <summary>How aggressively the camera tries to follow the target in the screen-horizontal direction.
            Small numbers are more responsive, rapidly orienting the camera to keep the target in
            the dead zone. Larger numbers give a more heavy slowly responding camera.
            Using different vertical and horizontal settings can yield a wide range of camera behaviors.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_VerticalDamping">
            <summary>How aggressively the camera tries to follow the target in the screen-vertical direction. 
            Small numbers are more responsive, rapidly orienting the camera to keep the target in 
            the dead zone. Larger numbers give a more heavy slowly responding camera. Using different vertical 
            and horizontal settings can yield a wide range of camera behaviors.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_ScreenX">
            <summary>Horizontal screen position for target. The camera will rotate to the position the tracked object here</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_ScreenY">
            <summary>Vertical screen position for target, The camera will rotate to to position the tracked object here</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_DeadZoneWidth">
            <summary>Camera will not rotate horizontally if the target is within this range of the position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_DeadZoneHeight">
            <summary>Camera will not rotate vertically if the target is within this range of the position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_SoftZoneWidth">
            <summary>When target is within this region, camera will gradually move to re-align
            towards the desired position, depending onm the damping speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_SoftZoneHeight">
            <summary>When target is within this region, camera will gradually move to re-align
            towards the desired position, depending onm the damping speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_BiasX">
            <summary>A non-zero bias will move the targt position away from the center of the soft zone</summary>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_BiasY">
            <summary>A non-zero bias will move the targt position away from the center of the soft zone</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.IsValid">
            <summary>True if component is enabled and has a LookAt defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.TrackedPoint">
            <summary>Internal API for inspector</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComposer.GetLookAtPointAndSetTrackedPoint(UnityEngine.Vector3)">
            <summary>Apply the target offsets to the target location.
            Also set the TrackedPoint property, taking lookahead into account.</summary>
            <param name="lookAt">The unoffset LookAt point</param>
            <returns>The LookAt point with the offset applied</returns>
        </member>
        <member name="F:Cinemachine.CinemachineComposer.m_CameraPosPrevFrame">
            <summary>State information for damping</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.SoftGuideRect">
            <summary>Internal API for the inspector editor</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComposer.HardGuideRect">
            <summary>Internal API for the inspector editor</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComposer.RotateToScreenBounds(Cinemachine.CameraState@,UnityEngine.Rect,UnityEngine.Quaternion@,System.Single,System.Single,System.Single)">
            <summary>
            Adjust the rigOrientation to put the camera within the screen bounds.
            If deltaTime >= 0 then damping will be applied.
            Assumes that currentOrientation fwd is such that input rigOrientation's
            local up is NEVER NEVER NEVER pointing downwards, relative to
            state.ReferenceUp.  If this condition is violated
            then you will see crazy spinning.  That's the symptom.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineComposer.ClampVerticalBounds(UnityEngine.Rect@,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Prevent upside-down camera situation.  This can happen if we have a high
            camera pitch combined with composer settings that cause the camera to tilt
            beyond the vertical in order to produce the desired framing.  We prevent this by
            clamping the composer's vertical settings so that this situation can't happen.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineFramingTransposer">
            <summary>
            This is a Cinemachine Component in the Body section of the component pipeline. 
            Its job is to position the camera in a fixed screen-space relationship to 
            the vcam's Follow target object, with offsets and damping.
            
            The camera will be first moved along the camera Z axis until the Follow target
            is at the desired distance from the camera's X-Y plane.  The camera will then
            be moved in its XY plane until the Follow target is at the desired point on
            the camera's screen.
            
            The FramingTansposer will only change the camera's position in space.  It will not 
            re-orient or otherwise aim the camera.
            
            For this component to work properly, the vcam's LookAt target must be null.
            The Follow target will define what the camera is looking at.
            
            If the Follow target is a CinemachineTargetGroup, then additional controls will 
            be available to dynamically adjust the camera’s view in order to frame the entire group.
            
            Although this component was designed for orthographic cameras, it works equally  
            well with persective cameras and can be used in 3D environments.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.OnGUICallback">
            <summary>Used by the Inspector Editor to display on-screen guides.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_LookaheadTime">
            <summary>This setting will instruct the composer to adjust its target offset based
            on the motion of the target.  The composer will look at a point where it estimates
            the target will be this many seconds into the future.  Note that this setting is sensitive
            to noisy animation, and can amplify the noise, resulting in undesirable camera jitter.
            If the camera jitters unacceptably when the target is in motion, turn down this setting, 
            or animate the target more smoothly.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_LookaheadSmoothing">
            <summary>Controls the smoothness of the lookahead algorithm.  Larger values smooth out 
            jittery predictions and also increase prediction lag</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_XDamping">
            <summary>How aggressively the camera tries to maintain the offset in the X-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            x-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_YDamping">
            <summary>How aggressively the camera tries to maintain the offset in the Y-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            y-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_ZDamping">
            <summary>How aggressively the camera tries to maintain the offset in the Z-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the
            target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_ScreenX">
            <summary>Horizontal screen position for target. The camera will move to position the tracked object here</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_ScreenY">
            <summary>Vertical screen position for target, The camera will move to to position the tracked object here</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_CameraDistance">
            <summary>The distance along the camera axis that will be maintained from the Follow target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_DeadZoneWidth">
            <summary>Camera will not move horizontally if the target is within this range of the position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_DeadZoneHeight">
            <summary>Camera will not move vertically if the target is within this range of the position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_DeadZoneDepth">
            <summary>The camera will not move along its z-axis if the Follow target is within this distance of the specified camera distance</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_SoftZoneWidth">
            <summary>When target is within this region, camera will gradually move to re-align
            towards the desired position, depending onm the damping speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_SoftZoneHeight">
            <summary>When target is within this region, camera will gradually move to re-align
            towards the desired position, depending onm the damping speed</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_BiasX">
            <summary>A non-zero bias will move the targt position away from the center of the soft zone</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_BiasY">
            <summary>A non-zero bias will move the targt position away from the center of the soft zone</summary>
        </member>
        <member name="T:Cinemachine.CinemachineFramingTransposer.FramingMode">
            <summary>What screen dimensions to consider when framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.FramingMode.Horizontal">
            <summary>Consider only the horizontal dimension.  Vertical framing is ignored.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.FramingMode.Vertical">
            <summary>Consider only the vertical dimension.  Horizontal framing is ignored.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.FramingMode.HorizontalAndVertical">
            <summary>The larger of the horizontal and vertical dimensions will dominate, to get the best fit.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.FramingMode.None">
            <summary>Don't do any framing adjustment</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_GroupFramingMode">
            <summary>What screen dimensions to consider when framing</summary>
        </member>
        <member name="T:Cinemachine.CinemachineFramingTransposer.AdjustmentMode">
            <summary>How to adjust the camera to get the desired framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.AdjustmentMode.ZoomOnly">
            <summary>Do not move the camera, only adjust the FOV.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.AdjustmentMode.DollyOnly">
            <summary>Just move the camera, don't change the FOV.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.AdjustmentMode.DollyThenZoom">
            <summary>Move the camera as much as permitted by the ranges, then
            adjust the FOV if necessary to make the shot.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_AdjustmentMode">
            <summary>How to adjust the camera to get the desired framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_GroupFramingSize">
            <summary>How much of the screen to fill with the bounding box of the targets.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaxDollyIn">
            <summary>How much closer to the target can the camera go?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaxDollyOut">
            <summary>How much farther from the target can the camera go?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MinimumDistance">
            <summary>Set this to limit how close to the target the camera can get</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaximumDistance">
            <summary>Set this to limit how far from the taregt the camera can get</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MinimumFOV">
            <summary>If adjusting FOV, will not set the FOV lower than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaximumFOV">
            <summary>If adjusting FOV, will not set the FOV higher than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MinimumOrthoSize">
            <summary>If adjusting Orthographic Size, will not set it lower than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_MaximumOrthoSize">
            <summary>If adjusting Orthographic Size, will not set it higher than this</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.SoftGuideRect">
            <summary>Internal API for the inspector editor</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.HardGuideRect">
            <summary>Internal API for the inspector editor</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.IsValid">
            <summary>True if component is enabled and has a valid Follow target</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Body stage</summary>
        </member>
        <member name="F:Cinemachine.CinemachineFramingTransposer.m_PreviousCameraPosition">
            <summary>State information for damping</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.TrackedPoint">
            <summary>Internal API for inspector</summary>
        </member>
        <member name="M:Cinemachine.CinemachineFramingTransposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.m_LastBounds">
            <summary>For editor visulaization of the calculated bounding box of the group</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.m_lastBoundsMatrix">
            <summary>For editor visualization of the calculated bounding box of the group</summary>
        </member>
        <member name="P:Cinemachine.CinemachineFramingTransposer.TargetGroup">
            <summary>Get Follow target as CinemachineTargetGroup, or null if target is not a group</summary>
        </member>
        <member name="T:Cinemachine.CinemachineGroupComposer">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera at a target object, with configurable offsets, damping, 
            and composition rules.
            
            In addition, if the target is a CinemachineTargetGroup, the behaviour
            will adjust the FOV and the camera distance to ensure that the entire group of targets
            is framed properly.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_GroupFramingSize">
            <summary>How much of the screen to fill with the bounding box of the targets.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineGroupComposer.FramingMode">
            <summary>What screen dimensions to consider when framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.FramingMode.Horizontal">
            <summary>Consider only the horizontal dimension.  Vertical framing is ignored.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.FramingMode.Vertical">
            <summary>Consider only the vertical dimension.  Horizontal framing is ignored.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.FramingMode.HorizontalAndVertical">
            <summary>The larger of the horizontal and vertical dimensions will dominate, to get the best fit.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_FramingMode">
            <summary>What screen dimensions to consider when framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_FrameDamping">
            <summary>How aggressively the camera tries to frame the group.
            Small numbers are more responsive</summary>
        </member>
        <member name="T:Cinemachine.CinemachineGroupComposer.AdjustmentMode">
            <summary>How to adjust the camera to get the desired framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.AdjustmentMode.ZoomOnly">
            <summary>Do not move the camera, only adjust the FOV.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.AdjustmentMode.DollyOnly">
            <summary>Just move the camera, don't change the FOV.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.AdjustmentMode.DollyThenZoom">
            <summary>Move the camera as much as permitted by the ranges, then
            adjust the FOV if necessary to make the shot.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_AdjustmentMode">
            <summary>How to adjust the camera to get the desired framing</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaxDollyIn">
            <summary>How much closer to the target can the camera go?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaxDollyOut">
            <summary>How much farther from the target can the camera go?</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MinimumDistance">
            <summary>Set this to limit how close to the target the camera can get</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaximumDistance">
            <summary>Set this to limit how far from the taregt the camera can get</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MinimumFOV">
            <summary>If adjusting FOV, will not set the FOV lower than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaximumFOV">
            <summary>If adjusting FOV, will not set the FOV higher than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MinimumOrthoSize">
            <summary>If adjusting Orthographic Size, will not set it lower than this</summary>
        </member>
        <member name="F:Cinemachine.CinemachineGroupComposer.m_MaximumOrthoSize">
            <summary>If adjusting Orthographic Size, will not set it higher than this</summary>
        </member>
        <member name="P:Cinemachine.CinemachineGroupComposer.TargetGroup">
            <summary>Get LookAt target as CinemachineTargetGroup, or null if target is not a group</summary>
        </member>
        <member name="M:Cinemachine.CinemachineGroupComposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="state">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="P:Cinemachine.CinemachineGroupComposer.m_LastBounds">
            <summary>For editor visulaization of the calculated bounding box of the group</summary>
        </member>
        <member name="P:Cinemachine.CinemachineGroupComposer.m_lastBoundsMatrix">
            <summary>For editor visualization of the calculated bounding box of the group</summary>
        </member>
        <member name="T:Cinemachine.CinemachineHardLockToTarget">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to place the camera on the Follow Target.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineHardLockToTarget.IsValid">
            <summary>True if component is enabled and has a LookAt defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachineHardLockToTarget.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineHardLockToTarget.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="T:Cinemachine.CinemachineHardLookAt">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera hard at the LookAt target.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineHardLookAt.IsValid">
            <summary>True if component is enabled and has a LookAt defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachineHardLookAt.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineHardLookAt.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer">
            <summary>
            This is a CinemachineComponent in the the Body section of the component pipeline. 
            Its job is to position the camera in a variable relationship to a the vcam's 
            Follow target object, with offsets and damping.
            
            This component is typically used to implement a camera that follows its target.
            It can accept player input from an input device, which allows the player to 
            dynamically control the relationship between the camera and the target, 
            for example with a joystick.
            
            The OrbitalTransposer introduces the concept of __Heading__, which is the direction
            in which the target is moving, and the OrbitalTransposer will attempt to position 
            the camera in relationship to the heading, which is by default directly behind the target.
            You can control the default relationship by adjusting the Heading Bias setting.
            
            If you attach an input controller to the OrbitalTransposer, then the player can also
            control the way the camera positions itself in relation to the target heading.  This allows
            the camera to move to any spot on an orbit around the target.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer.Heading">
            <summary>
            How the "forward" direction is defined.  Orbital offset is in relation to the forward
            direction.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition">
            <summary>
            Sets the algorithm for determining the target's heading for purposes
            of re-centering the camera
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.PositionDelta">
            <summary>
            Target heading calculated from the difference between its position on
            the last update and current frame.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.Velocity">
            <summary>
            Target heading calculated from its <b>Rigidbody</b>'s velocity.
            If no <b>Rigidbody</b> exists, it will fall back
            to HeadingDerivationMode.PositionDelta
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.TargetForward">
            <summary>
            Target heading calculated from the Target <b>Transform</b>'s euler Y angle
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition.WorldForward">
            <summary>
            Default heading is a constant world space heading.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.m_HeadingDefinition">
            <summary>The method by which the 'default heading' is calculated if
            recentering to target heading is enabled</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.m_VelocityFilterStrength">
            <summary>Size of the velocity sampling window for target heading filter.
            Used only if deriving heading from target's movement</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Heading.m_HeadingBias">
            <summary>Additional Y rotation applied to the target heading.
            When this value is 0, the camera will be placed behind the target</summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.Heading.#ctor(Cinemachine.CinemachineOrbitalTransposer.Heading.HeadingDefinition,System.Int32,System.Single)">
            <summary>Constructor</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.m_Heading">
            <summary>The definition of Forward.  Camera will follow behind.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer.Recentering">
            <summary>Controls how automatic orbit recentering occurs</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Recentering.m_enabled">
            <summary>If checked, will enable automatic recentering of the
            camera based on the heading calculation mode. If FALSE, recenting is disabled.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Recentering.m_RecenterWaitTime">
            <summary>If no input has been detected, the camera will wait
            this long in seconds before moving its heading to the default heading.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.Recentering.m_RecenteringTime">
            <summary>Maximum angular speed of recentering.  Will accelerate into and decelerate out of this</summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.Recentering.#ctor(System.Boolean,System.Single,System.Single)">
            <summary>Constructor with specific field values</summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.Recentering.Validate">
            <summary>Call this from OnValidate()</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.m_RecenterToTargetHeading">
            <summary>Parameters that control Automating Heading Recentering</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.m_XAxis">
            <summary>Axis representing the current heading.  Value is in degrees
            and represents a rotation about the up vector</summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.m_HeadingIsSlave">
            <summary>
            Drive the x-axis setting programmatically.
            Automatic heading updating will be disabled.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineOrbitalTransposer.UpdateHeadingDelegate">
            <summary>
            Delegate that allows the the m_XAxis object to be replaced with another one.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineOrbitalTransposer.HeadingUpdater">
            <summary>
            Delegate that allows the the XAxis object to be replaced with another one.
            To use it, just call orbital.UpdateHeading() with a reference to a 
            private AxisState object, and that AxisState object will be updated and
            used to calculate the heading.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.UpdateHeading(System.Single,UnityEngine.Vector3,Cinemachine.AxisState@)">
            <summary>
            Update the X axis and calculate the heading.  This can be called by a delegate
            with a custom axis.
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
            <param name="up">World Up, set by the CinemachineBrain</param>
            <param name="axis"></param>
            <returns>Axis value</returns>
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
        </member>
        <member name="M:Cinemachine.CinemachineOrbitalTransposer.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.
            This implementation adds the delta to the follow offset, after zeroing out local x.</summary>
            <param name="delta">The amount dragged this frame</param>
        </member>
        <member name="T:Cinemachine.CinemachinePOV">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera in response to the user's mouse or joystick input.
            
            The composer does not change the camera's position.  It will only pan and tilt the 
            camera where it is, in order to get the desired framing.  To move the camera, you have
            to use the virtual camera's Body section.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachinePOV.m_VerticalAxis">
            <summary>The Vertical axis.  Value is -90..90. Controls the vertical orientation</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePOV.m_HorizontalAxis">
            <summary>The Horizontal axis.  Value is -180..180.  Controls the horizontal orientation</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePOV.IsValid">
            <summary>True if component is enabled and has a LookAt defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePOV.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePOV.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the axis values and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  Not used.</param>
        </member>
        <member name="T:Cinemachine.CinemachineSameAsFollowObject">
            <summary>
            This is a CinemachineComponent in the Aim section of the component pipeline.
            Its job is to aim the camera hard at the LookAt target.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineSameAsFollowObject.IsValid">
            <summary>True if component is enabled and has a Follow target defined</summary>
        </member>
        <member name="P:Cinemachine.CinemachineSameAsFollowObject.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Aim stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineSameAsFollowObject.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Applies the composer rules and orients the camera accordingly</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for calculating damping.  If less than
            zero, then target will snap to the center of the dead zone.</param>
        </member>
        <member name="T:Cinemachine.CinemachineTrackedDolly">
            <summary>
            A Cinemachine Virtual Camera Body component that constrains camera motion
            to a CinemachinePath.  The camera can move along the path.
            
            This behaviour can operate in two modes: manual positioning, and Auto-Dolly positioning.  
            In Manual mode, the camera's position is specified by animating the Path Position field.  
            In Auto-Dolly mode, the Path Position field is animated automatically every frame by finding
            the position on the path that's closest to the virtual camera's Follow target.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_Path">
            <summary>The path to which the camera will be constrained.  This must be non-null.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_PathPosition">
            <summary>The position along the path at which the camera will be placed.
            This can be animated directly, or set automatically by the Auto-Dolly feature
            to get as close as possible to the Follow target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_PositionUnits">
            <summary>How to interpret the Path Position</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_PathOffset">
            <summary>Where to put the camera realtive to the path postion.  X is perpendicular to the path, Y is up, and Z is parallel to the path.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_XDamping">
            <summary>How aggressively the camera tries to maintain the offset perpendicular to the path.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            x-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_YDamping">
            <summary>How aggressively the camera tries to maintain the offset in the path-local up direction.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            y-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_ZDamping">
            <summary>How aggressively the camera tries to maintain the offset parallel to the path.
            Small numbers are more responsive, rapidly translating the camera to keep the
            target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTrackedDolly.CameraUpMode">
            <summary>Different ways to set the camera's up vector</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.Default">
            <summary>Leave the camera's up vector alone.  It will be set according to the Brain's WorldUp.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.Path">
            <summary>Take the up vector from the path's up vector at the current point</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.PathNoRoll">
            <summary>Take the up vector from the path's up vector at the current point, but with the roll zeroed out</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.FollowTarget">
            <summary>Take the up vector from the Follow target's up vector</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.CameraUpMode.FollowTargetNoRoll">
            <summary>Take the up vector from the Follow target's up vector, but with the roll zeroed out</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_CameraUp">
            <summary>How to set the virtual camera's Up vector.  This will affect the screen composition.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_PitchDamping">
            <summary>"How aggressively the camera tries to track the target rotation's X angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_YawDamping">
            <summary>How aggressively the camera tries to track the target rotation's Y angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_RollDamping">
            <summary>How aggressively the camera tries to track the target rotation's Z angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineTrackedDolly.AutoDolly">
            <summary>Controls how automatic dollying occurs</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.AutoDolly.m_Enabled">
            <summary>If checked, will enable automatic dolly, which chooses a path position
            that is as close as possible to the Follow target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.AutoDolly.m_PositionOffset">
            <summary>Offset, in current position units, from the closest point on the path to the follow target.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.AutoDolly.m_SearchRadius">
            <summary>Search up to how many waypoints on either side of the current position.  Use 0 for Entire path</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.AutoDolly.m_SearchResolution">
            <summary>We search between waypoints by dividing the segment into this many straight pieces.
            The higher the number, the more accurate the result, but performance is
            proportionally slower for higher numbers</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTrackedDolly.AutoDolly.#ctor(System.Boolean,System.Single,System.Int32,System.Int32)">
            <summary>Constructor with specific field values</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTrackedDolly.m_AutoDolly">
            <summary>Controls how automatic dollying occurs</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTrackedDolly.IsValid">
            <summary>True if component is enabled and has a path</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTrackedDolly.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Body stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTrackedDolly.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for damping.  If less that 0, no damping is done.</param>
        </member>
        <member name="M:Cinemachine.CinemachineTrackedDolly.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.
            This implementation adds the delta to the follow offset.</summary>
            <param name="delta">The amount dragged this frame</param>
        </member>
        <member name="T:Cinemachine.CinemachineTransposer">
            <summary>
            This is a CinemachineComponent in the Body section of the component pipeline. 
            Its job is to position the camera in a fixed relationship to the vcam's Follow 
            target object, with offsets and damping.
            
            The Tansposer will only change the camera's position in space.  It will not 
            re-orient or otherwise aim the camera.  To to that, you need to instruct 
            the vcam in the Aim section of its pipeline.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineTransposer.BindingMode">
            <summary>
            The coordinate space to use when interpreting the offset from the target
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.LockToTargetOnAssign">
            <summary>
            Camera will be bound to the Follow target using a frame of reference consisting
            of the target's local frame at the moment when the virtual camera was enabled,
            or when the target was assigned.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.LockToTargetWithWorldUp">
            <summary>
            Camera will be bound to the Follow target using a frame of reference consisting
            of the target's local frame, with the tilt and roll zeroed out.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.LockToTargetNoRoll">
            <summary>
            Camera will be bound to the Follow target using a frame of reference consisting
            of the target's local frame, with the roll zeroed out.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.LockToTarget">
            <summary>
            Camera will be bound to the Follow target using the target's local frame.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.WorldSpace">
            <summary>Camera will be bound to the Follow target using a world space offset.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.BindingMode.SimpleFollowWithWorldUp">
            <summary>Offsets will be calculated relative to the target, using Camera-local axes</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_BindingMode">
            <summary>The coordinate space to use when interpreting the offset from the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_FollowOffset">
            <summary>The distance which the transposer will attempt to maintain from the transposer subject</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_XDamping">
            <summary>How aggressively the camera tries to maintain the offset in the X-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            x-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_YDamping">
            <summary>How aggressively the camera tries to maintain the offset in the Y-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the target's
            y-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_ZDamping">
            <summary>How aggressively the camera tries to maintain the offset in the Z-axis.
            Small numbers are more responsive, rapidly translating the camera to keep the
            target's z-axis offset.  Larger numbers give a more heavy slowly responding camera.
            Using different settings per axis can yield a wide range of camera behaviors</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_PitchDamping">
            <summary>How aggressively the camera tries to track the target rotation's X angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_YawDamping">
            <summary>How aggressively the camera tries to track the target rotation's Y angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_RollDamping">
            <summary>How aggressively the camera tries to track the target rotation's Z angle.  
            Small numbers are more responsive.  Larger numbers give a more heavy slowly responding camera.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.EffectiveOffset">
            <summary>Get the target offset, with sanitization</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.IsValid">
            <summary>True if component is enabled and has a valid Follow target</summary>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.Stage">
            <summary>Get the Cinemachine Pipeline stage that this component implements.
            Always returns the Body stage</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="curState">The current camera state</param>
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.
            This implementation adds the delta to the follow offset.</summary>
            <param name="delta">The amount dragged this frame</param>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.InitPrevFrameStateInfo(Cinemachine.CameraState@,System.Single)">
            <summary>Initializes the state for previous frame if appropriate.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.TrackTarget(System.Single,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3@,UnityEngine.Quaternion@)">
            <summary>Positions the virtual camera according to the transposer rules.</summary>
            <param name="deltaTime">Used for damping.  If less than 0, no damping is done.</param>
            <param name="up">Current camera up</param>
            <param name="desiredCameraOffset">Where we want to put the camera relative to the follow target</param>
            <param name="outTargetPosition">Resulting camera position</param>
            <param name="outTargetOrient">Damped target orientation</param>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.Damping">
            <summary>
            Damping speeds for each of the 3 axes of the offset from target
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineTransposer.AngularDamping">
            <summary>
            Damping speeds for each of the 3 axes of the target's rotation
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.GeTargetCameraPosition(UnityEngine.Vector3)">
            <summary>Internal API for the Inspector Editor, so it can draw a marker at the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineTransposer.m_PreviousTargetPosition">
            <summary>State information for damping</summary>
        </member>
        <member name="M:Cinemachine.CinemachineTransposer.GetReferenceOrientation(UnityEngine.Vector3)">
            <summary>Internal API for the Inspector Editor, so it can draw a marker at the target</summary>
        </member>
        <member name="T:Cinemachine.AxisState">
            <summary>
            Axis state for defining to react to player input.  
            The settings here control the responsiveness of the axis to player input.
            </summary>
        </member>
        <member name="F:Cinemachine.AxisState.Value">
            <summary>The current value of the axis</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_MaxSpeed">
            <summary>How fast the axis value can travel.  Increasing this number
            makes the behaviour more responsive to joystick input</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_AccelTime">
            <summary>The amount of time in seconds it takes to accelerate to
            MaxSpeed with the supplied Axis at its maximum value</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_DecelTime">
            <summary>The amount of time in seconds it takes to decelerate
            the axis to zero if the supplied axis is in a neutral position</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_InputAxisName">
            <summary>The name of this axis as specified in Unity Input manager.
            Setting to an empty string will disable the automatic updating of this axis</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_InputAxisValue">
            <summary>The value of the input axis.  A value of 0 means no input
            You can drive this directly from a
            custom input system, or you can set the Axis Name and have the value
            driven by the internal Input Manager</summary>
        </member>
        <member name="F:Cinemachine.AxisState.m_InvertAxis">
            <summary>If checked, then the raw value of the input axis will be inverted 
            before it is used.</summary>
        </member>
        <member name="M:Cinemachine.AxisState.#ctor(System.Single,System.Single,System.Single,System.Single,System.String,System.Boolean)">
            <summary>Constructor with specific values</summary>
        </member>
        <member name="M:Cinemachine.AxisState.Validate">
            <summary>Call from OnValidate: Make sure the fields are sensible</summary>
        </member>
        <member name="M:Cinemachine.AxisState.SetThresholds(System.Single,System.Single,System.Boolean)">
            <summary>
            Sets the constraints by which this axis will operate on
            </summary>
            <param name="minValue">The lowest value this axis can achieve</param>
            <param name="maxValue">The highest value this axis can achieve</param>
            <param name="wrapAround">If <b>true</b>, values commanded greater
            than mMaxValue or less than mMinValue will wrap around.
            If <b>false</b>, the value will be clamped within the range.</param>
        </member>
        <member name="M:Cinemachine.AxisState.Update(System.Single)">
            <summary>
            Updates the state of this axis based on the axis defined
            by AxisState.m_AxisName
            </summary>
            <param name="deltaTime">Delta time in seconds</param>
            <returns>Returns <b>true</b> if this axis' input was non-zero this Update,
            <b>flase</b> otherwise</returns>
        </member>
        <member name="T:Cinemachine.CameraState">
            <summary>
            The output of the Cinemachine engine for a specific virtual camera.  The information
            in this struct can be blended, and provides what is needed to calculate an
            appropriate camera position, orientation, and lens setting.
            
            Raw values are what the Cinemachine behaviours generate.  The correction channel
            holds perturbations to the raw values - e.g. noise or smoothing, or obstacle
            avoidance corrections.  Coirrections are not considered when making time-based
            calculations such as damping.
            
            The Final position and orientation is the comination of the raw values and
            their corrections.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.Lens">
            <summary>
            Camera Lens Settings.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.ReferenceUp">
            <summary>
            Which way is up.  World space unit vector.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.ReferenceLookAt">
            <summary>
            The world space focus point of the camera.  What the camera wants to look at.
            There is a special constant define to represent "nothing".  Be careful to 
            check for that (or check the HasLookAt property).
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.HasLookAt">
            <summary>
            Returns true if this state has a valid ReferenceLookAt value.
            </summary>
        </member>
        <member name="F:Cinemachine.CameraState.kNoPoint">
            <summary>
            This constant represents "no point in space" or "no direction".
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.RawPosition">
            <summary>
            Raw (un-corrected) world space position of this camera
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.RawOrientation">
            <summary>
            Raw (un-corrected) world space orientation of this camera
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.PositionDampingBypass">
            <summary>This is a way for the Body component to bypass aim damping,
            useful for when the body need to rotate its point of view, but does not
            want interference from the aim damping</summary>
        </member>
        <member name="P:Cinemachine.CameraState.ShotQuality">
            <summary>
            Subjective estimation of how "good" the shot is.
            Larger values mean better quality.  Default is 1.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.PositionCorrection">
            <summary>
            Position correction.  This will be added to the raw position.
            This value doesn't get fed back into the system when calculating the next frame.
            Can be noise, or smoothing, or both, or something else.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.OrientationCorrection">
            <summary>
            Orientation correction.  This will be added to the raw orientation.
            This value doesn't get fed back into the system when calculating the next frame.
            Can be noise, or smoothing, or both, or something else.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.CorrectedPosition">
            <summary>
            Position with correction applied.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.CorrectedOrientation">
            <summary>
            Orientation with correction applied.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.FinalPosition">
            <summary>
            Position with correction applied.  This is what the final camera gets.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.FinalOrientation">
            <summary>
            Orientation with correction and dutch applied.  This is what the final camera gets.
            </summary>
        </member>
        <member name="P:Cinemachine.CameraState.Default">
            <summary>
            State with default values
            </summary>
        </member>
        <member name="T:Cinemachine.CameraState.CustomBlendable">
            <summary>Opaque structure represent extra blendable stuff and its weight.
            The base system ignores this data - it is intended for extension modules</summary>
        </member>
        <member name="F:Cinemachine.CameraState.CustomBlendable.m_Custom">
            <summary>The custom stuff that the extention module will consider</summary>
        </member>
        <member name="F:Cinemachine.CameraState.CustomBlendable.m_Weight">
            <summary>The weight of the custom stuff.  Must be 0...1</summary>
        </member>
        <member name="M:Cinemachine.CameraState.CustomBlendable.#ctor(UnityEngine.Object,System.Single)">
            <summary>Constructor with specific values</summary>
            <param name="custom">The custom stuff that the extention module will consider</param>
            <param name="weight">The weight of the custom stuff.  Must be 0...1</param>
        </member>
        <member name="P:Cinemachine.CameraState.NumCustomBlendables">
            <summary>The number of custom blendables that will be applied to the camera.  
            The base system manages but otherwise ignores this data - it is intended for 
            extension modules</summary>
        </member>
        <member name="M:Cinemachine.CameraState.GetCustomBlendable(System.Int32)">
            <summary>Get a custom blendable that will be applied to the camera.  
            The base system manages but otherwise ignores this data - it is intended for 
            extension modules</summary>
            <param name="index">Which one to get.  Must be in range [0...NumCustomBlendables)</param>
            <returns>The custom blendable at the specified index.</returns>
        </member>
        <member name="M:Cinemachine.CameraState.AddCustomBlendable(Cinemachine.CameraState.CustomBlendable)">
            <summary>Add a custom blendable to the pot for eventual application to the camera.
            The base system manages but otherwise ignores this data - it is intended for 
            extension modules</summary>
            <param name="b">The custom blendable to add.  If b.m_Custom is the same as an 
            already-added custom blendable, then they will be merged and the weights combined.</param>
        </member>
        <member name="M:Cinemachine.CameraState.Lerp(Cinemachine.CameraState,Cinemachine.CameraState,System.Single)">
            <summary>Intelligently blend the contents of two states.</summary>
            <param name="stateA">The first state, corresponding to t=0</param>
            <param name="stateB">The second state, corresponding to t=1</param>
            <param name="t">How much to interpolate.  Internally clamped to 0..1</param>
            <returns>Linearly interpolated CameraState</returns>
        </member>
        <member name="T:Cinemachine.CinemachineBlend">
            <summary>
            Describes a blend between 2 Cinemachine Virtual Cameras, and holds the
            current state of the blend.
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.CamA">
            <summary>First camera in the blend</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.CamB">
            <summary>Second camera in the blend</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.BlendCurve">
            <summary>The curve that describes the way the blend transitions over time
            from the first camera to the second.  X-axis is time in seconds over which
            the blend takes place and Y axis is blend weight (0..1)</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.TimeInBlend">
            <summary>The current time relative to the start of the blend</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.BlendWeight">
            <summary>The current weight of the blend.  This is an evaluation of the
            BlendCurve at the current time relative to the start of the blend.
            0 means camA, 1 means camB.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.IsValid">
            <summary>Validity test for the blend.  True if both cameras are defined.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.Duration">
            <summary>Duration in seconds of the blend.
            This is given read from the BlendCurve.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.IsComplete">
            <summary>True if the time relative to the start of the blend is greater
            than or equal to the blend duration</summary>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.Description">
            <summary>Text description of the blend, for debugging</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlend.Uses(Cinemachine.ICinemachineCamera)">
            <summary>Does the blend use a specific Cinemachine Virtual Camera?</summary>
            <param name="cam">The camera to test</param>
            <returns>True if the camera is involved in the blend</returns>
        </member>
        <member name="M:Cinemachine.CinemachineBlend.#ctor(Cinemachine.ICinemachineCamera,Cinemachine.ICinemachineCamera,UnityEngine.AnimationCurve,System.Single,System.Single)">
            <summary>Construct a blend</summary>
            <param name="a">First camera</param>
            <param name="b">Second camera</param>
            <param name="curve">Blend curve</param>
            <param name="t">Current time in blend, relative to the start of the blend</param>
        </member>
        <member name="M:Cinemachine.CinemachineBlend.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Make sure the source cameras get updated.</summary>
            <param name="worldUp">Default world up.  Individual vcams may modify this</param>
            <param name="deltaTime">Time increment used for calculating time-based behaviours (e.g. damping)</param>
        </member>
        <member name="P:Cinemachine.CinemachineBlend.State">
            <summary>Compute the blended CameraState for the current time in the blend.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlendDefinition">
            <summary>Definition of a Camera blend.  This struct holds the information
            necessary to generate a suitable AnimationCurve for a Cinemachine Blend.</summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlendDefinition.Style">
            <summary>Supported predefined shapes for the blend curve.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.Cut">
            <summary>Zero-length blend</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.EaseInOut">
            <summary>S-shaped curve, giving a gentle and smooth transition</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.EaseIn">
            <summary>Linear out of the outgoing shot, and easy into the incoming</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.EaseOut">
            <summary>Easy out of the outgoing shot, and linear into the incoming</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.HardIn">
            <summary>Easy out of the outgoing, and hard into the incoming</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.HardOut">
            <summary>Hard out of the outgoing, and easy into the incoming</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.Style.Linear">
            <summary>Linear blend.  Mechanical-looking.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.m_Style">
            <summary>The shape of the blend curve.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlendDefinition.m_Time">
            <summary>The duration (in seconds) of the blend</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlendDefinition.#ctor(Cinemachine.CinemachineBlendDefinition.Style,System.Single)">
            <summary>Constructor</summary>
            <param name="style">The shape of the blend curve.</param>
            <param name="time">The duration (in seconds) of the blend</param>
        </member>
        <member name="P:Cinemachine.CinemachineBlendDefinition.BlendCurve">
            <summary>
            An AnimationCurve specifying the interpolation duration and value
            for this camera blend. The time of the last key frame is assumed to the be the
            duration of the blend. Y-axis values must be in range [0,1] (internally clamped
            within Blender) and time must be in range of [0, +infinity)
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlenderSettings">
            <summary>
            Asset that defines the rules for blending between Virtual Cameras.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlenderSettings.CustomBlend">
            <summary>
            Container specifying how two specific Cinemachine Virtual Cameras
            blend together.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlenderSettings.m_CustomBlends">
            <summary>The array containing explicitly defined blends between two Virtual Cameras</summary>
        </member>
        <member name="F:Cinemachine.CinemachineBlenderSettings.kBlendFromAnyCameraLabel">
            <summary>Internal API for the inspector editopr: a label to represent any camera</summary>
        </member>
        <member name="M:Cinemachine.CinemachineBlenderSettings.GetBlendCurveForVirtualCameras(System.String,System.String,UnityEngine.AnimationCurve)">
            <summary>
            Attempts to find a blend curve which matches the to and from cameras as specified.
            If no match is found, the function returns either the
            default blend for this Blender or NULL depending on the state
            of <b>returnDefaultOnNoMatch</b>.
            </summary>
            <param name="fromCameraName">The game object name of the from camera</param>
            <param name="toCameraName">The game object name of the to camera</param>
            <param name="defaultCurve">Curve to return if no curve found.  Can be NULL.</param>
            <returns></returns>
        </member>
        <member name="T:Cinemachine.CinemachineComponentBase">
            <summary>
            An abstract representation of a mutator acting on a Cinemachine Virtual Camera
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineComponentBase.Epsilon">
            <summary>Useful constant for very small floats</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.VirtualCamera">
            <summary>Get the associated CinemachineVirtualCameraBase</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.FollowTarget">
            <summary>Returns the owner vcam's Follow target.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.LookAtTarget">
            <summary>Returns the owner vcam's LookAt target.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.VcamState">
            <summary>Returns the owner vcam's CameraState.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.IsValid">
            <summary>Returns true if this object is enabled and set up to produce results.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComponentBase.PrePipelineMutateCameraState(Cinemachine.CameraState@)">
            <summary>Override this to do such things as offset the RefereceLookAt.
            Base class implementation does nothing.</summary>
            <param name="curState">Input state that must be mutated</param>
        </member>
        <member name="P:Cinemachine.CinemachineComponentBase.Stage">
            <summary>What part of the pipeline this fits into</summary>
        </member>
        <member name="M:Cinemachine.CinemachineComponentBase.MutateCameraState(Cinemachine.CameraState@,System.Single)">
            <summary>Mutates the camera state.  This state will later be applied to the camera.</summary>
            <param name="curState">Input state that must be mutated</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineComponentBase.OnPositionDragged(UnityEngine.Vector3)">
            <summary>API for the editor, to process a position drag from the user.
            Base class implementation does nothing.</summary>
            <param name="delta">The amount dragged this frame</param>
        </member>
        <member name="T:Cinemachine.CinemachineCore">
            <summary>A singleton that manages complete lists of CinemachineBrain and,
            Cinemachine Virtual Cameras, and the priority queue.  Provides
            services to keeping track of whether Cinemachine Virtual Cameras have
            been updated each frame.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.kStreamingVersion">
            <summary>Data version string.  Used to upgrade from legacy projects</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.kVersionString">
            <summary>Human-readable Cinemachine Version</summary>
        </member>
        <member name="T:Cinemachine.CinemachineCore.Stage">
            <summary>
            Stages in the Cinemachine Component pipeline, used for
            UI organization>.  This enum defines the pipeline order.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.Stage.Body">
            <summary>Second stage: position the camera in space</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.Stage.Aim">
            <summary>Third stage: orient the camera to point at the target</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.Stage.Noise">
            <summary>Final stage: apply noise (this is done separately, in the
            Correction channel of the CameraState)</summary>
        </member>
        <member name="P:Cinemachine.CinemachineCore.Instance">
            <summary>Get the singleton instance</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.sShowHiddenObjects">
            <summary>
            If true, show hidden Cinemachine objects, to make manual script mapping possible.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineCore.AxisInputDelegate">
            <summary>Delegate for overriding Unity's default input system.  Returns the value
            of the named axis.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.GetInputAxis">
            <summary>Delegate for overriding Unity's default input system.
            If you set this, then your delegate will be called instead of
            System.Input.GetAxis(axisName) whenever in-game user input is needed.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.mActiveBrains">
            <summary>List of all active CinemachineBrains.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineCore.BrainCount">
            <summary>Access the array of active CinemachineBrains in the scene</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GetActiveBrain(System.Int32)">
            <summary>Access the array of active CinemachineBrains in the scene 
            without gebnerating garbage</summary>
            <param name="index">Index of the brain to access, range 0-BrainCount</param>
            <returns>The brain at the specified index</returns>
        </member>
        <member name="M:Cinemachine.CinemachineCore.AddActiveBrain(Cinemachine.CinemachineBrain)">
            <summary>Called when a CinemachineBrain is enabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.RemoveActiveBrain(Cinemachine.CinemachineBrain)">
            <summary>Called when a CinemachineBrain is disabled.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineCore.mActiveCameras">
            <summary>List of all active ICinemachineCameras.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineCore.VirtualCameraCount">
            <summary>
            List of all active Cinemachine Virtual Cameras for all brains.
            This list is kept sorted by priority.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GetVirtualCamera(System.Int32)">
            <summary>Access the array of active ICinemachineCamera in the scene 
            without gebnerating garbage</summary>
            <param name="index">Index of the camera to access, range 0-VirtualCameraCount</param>
            <returns>The virtual camera at the specified index</returns>
        </member>
        <member name="M:Cinemachine.CinemachineCore.AddActiveCamera(Cinemachine.ICinemachineCamera)">
            <summary>Called when a Cinemachine Virtual Camera is enabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.RemoveActiveCamera(Cinemachine.ICinemachineCamera)">
            <summary>Called when a Cinemachine Virtual Camera is disabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.AddChildCamera(Cinemachine.ICinemachineCamera)">
            <summary>Called when a child vcam is enabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.RemoveChildCamera(Cinemachine.ICinemachineCamera)">
            <summary>Called when a child vcam is disabled.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.UpdateAllActiveVirtualCameras(UnityEngine.Vector3,System.Single)">
            <summary>Update all the active vcams in the scene, in the correct dependency order.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.UpdateVirtualCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>
            Update a single Cinemachine Virtual Camera if and only if it
            hasn't already been updated this frame.  Always update vcams via this method.
            Calling this more than once per frame for the same camera will have no effect.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineCore.UpdateFilter">
            <summary>Internal use only</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GetVcamUpdateStatus(Cinemachine.ICinemachineCamera)">
            <summary>Internal use only</summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.IsLive(Cinemachine.ICinemachineCamera)">
            <summary>
            Is this virtual camera currently actively controlling any Camera?
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GenerateCameraActivationEvent(Cinemachine.ICinemachineCamera)">
            <summary>
            Signal that the virtual has been activated.
            If the camera is live, then all CinemachineBrains that are showing it will
            send an activation event.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.GenerateCameraCutEvent(Cinemachine.ICinemachineCamera)">
            <summary>
            Signal that the virtual camera's content is discontinuous WRT the previous frame.
            If the camera is live, then all CinemachineBrains that are showing it will send a cut event.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineCore.FindPotentialTargetBrain(Cinemachine.ICinemachineCamera)">
            <summary>
            Try to find a CinemachineBrain to associate with a
            Cinemachine Virtual Camera.  The first CinemachineBrain
            in which this Cinemachine Virtual Camera is live will be used.
            If none, then the first active CinemachineBrain will be used.
            Brains with OutputCamera == null will not be returned.
            Final result may be null.
            </summary>
            <param name="vcam">Virtual camera whose potential brain we need.</param>
            <returns>First CinemachineBrain found that might be
            appropriate for this vcam, or null</returns>
        </member>
        <member name="T:Cinemachine.Utility.CinemachineGameWindowDebug">
            <summary>Manages onscreen positions for Cinemachine debugging output</summary>
        </member>
        <member name="M:Cinemachine.Utility.CinemachineGameWindowDebug.ReleaseScreenPos(UnityEngine.Object)">
            <summary>Release a screen rectangle previously obtained through GetScreenPos()</summary>
            <param name="client">The client caller.  Used as a handle.</param>
        </member>
        <member name="M:Cinemachine.Utility.CinemachineGameWindowDebug.GetScreenPos(UnityEngine.Object,System.String,UnityEngine.GUIStyle)">
            <summary>Reserve an on-screen rectangle for debugging output.</summary>
            <param name="client">The client caller.  This is used as a handle.</param>
            <param name="text">Sample text, for determining rectangle size</param>
            <param name="style">What style will be used to draw, used here for
            determining rect size</param>
            <returns>An area on the game screen large enough to print the text
            in the style indicated</returns>
        </member>
        <member name="M:Cinemachine.Utility.GaussianWindow1d`1.Value">
            Returned value will be kernelRadius old
        </member>
        <member name="T:Cinemachine.Utility.Damper">
            <summary>Utility to perform realistic damping of float or Vector3 values.
            The algorithm is based on exponentially decaying the delta until only
            a negligible amount remains.</summary>
        </member>
        <member name="F:Cinemachine.Utility.Damper.kNegligibleResidual">
            <summary>Standard residual</summary>
        </member>
        <member name="M:Cinemachine.Utility.Damper.Damp(System.Single,System.Single,System.Single)">
            <summary>Get a damped version of a quantity.  This is the portion of the
            quantity that will take effect over the given time.</summary>
            <param name="initial">The amount that will be damped</param>
            <param name="dampTime">The rate of damping.  This is the time it would 
            take to reduce the original amount to a negligible percentage</param>
            <param name="deltaTime">The time over which to damp</param>
            <returns>The damped amount.  This will be the original amount scaled by 
            a value between 0 and 1.</returns>
        </member>
        <member name="M:Cinemachine.Utility.Damper.Damp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>Get a damped version of a quantity.  This is the portion of the
            quantity that will take effect over the given time.</summary>
            <param name="initial">The amount that will be damped</param>
            <param name="dampTime">The rate of damping.  This is the time it would 
            take to reduce the original amount to a negligible percentage</param>
            <param name="deltaTime">The time over which to damp</param>
            <returns>The damped amount.  This will be the original amount scaled by 
            a value between 0 and 1.</returns>
        </member>
        <member name="M:Cinemachine.Utility.Damper.Damp(UnityEngine.Vector3,System.Single,System.Single)">
            <summary>Get a damped version of a quantity.  This is the portion of the
            quantity that will take effect over the given time.</summary>
            <param name="initial">The amount that will be damped</param>
            <param name="dampTime">The rate of damping.  This is the time it would 
            take to reduce the original amount to a negligible percentage</param>
            <param name="deltaTime">The time over which to damp</param>
            <returns>The damped amount.  This will be the original amount scaled by 
            a value between 0 and 1.</returns>
        </member>
        <member name="T:Cinemachine.Utility.ReflectionHelpers">
            <summary>An ad-hoc collection of helpers for reflection, used by Cinemachine
            or its editor tools in various places</summary>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.CopyFields(System.Object,System.Object,System.Reflection.BindingFlags)">
            <summary>Copy the fields from one object to another</summary>
            <param name="src">The source object to copy from</param>
            <param name="dst">The destination object to copy to</param>
            <param name="bindingAttr">The mask to filter the attributes.
            Only those fields that get caught in the filter will be copied</param>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetTypesInAssembly(System.Reflection.Assembly,System.Predicate{System.Type})">
            <summary>Search the assembly for all types that match a predicate</summary>
            <param name="assembly">The assembly to search</param>
            <param name="predicate">The type to look for</param>
            <returns>A list of types found in the assembly that inherit from the predicate</returns>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetTypeInAllLoadedAssemblies(System.String)">
            <summary>Get a type from a name</summary>
            <param name="typeName">The name of the type to search for</param>
            <returns>The type matching the name, or null if not found</returns>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetTypesInAllLoadedAssemblies(System.Predicate{System.Type})">
            <summary>Search all assemblies for all types that match a predicate</summary>
            <param name="predicate">The type to look for</param>
            <returns>A list of types found in the assembly that inherit from the predicate</returns>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetTypesInLoadedAssemblies(System.Predicate{System.Reflection.Assembly},System.Predicate{System.Type})">
            <summary>call GetTypesInAssembly() for all assemblies that match a predicate</summary>
            <param name="assemblyPredicate">Which assemblies to search</param>
            <param name="predicate">What type to look for</param>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.AccessInternalField``1(System.Type,System.Object,System.String)">
            <summary>Cheater extension to access internal field of an object</summary>
            <param name="type">The type of the field</param>
            <param name="obj">The object to access</param>
            <param name="memberName">The string name of the field to access</param>
            <returns>The value of the field in the objects</returns>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetParentObject(System.String,System.Object)">
            <summary>Get the object owner of a field.  This method processes
            the '.' separator to get from the object that owns the compound field
            to the object that owns the leaf field</summary>
            <param name="path">The name of the field, which may contain '.' separators</param>
            <param name="obj">the owner of the compound field</param>
        </member>
        <member name="M:Cinemachine.Utility.ReflectionHelpers.GetFieldPath``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>Returns a string path from an expression - mostly used to retrieve serialized properties
            without hardcoding the field path. Safer, and allows for proper refactoring.</summary>
        </member>
        <member name="T:Cinemachine.Utility.UnityVectorExtensions">
            <summary>Extensions to the Vector3 class, used by Cinemachine</summary>
        </member>
        <member name="F:Cinemachine.Utility.UnityVectorExtensions.Epsilon">
            <summary>A useful Epsilon</summary>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Get the closest point on a line segment.
            </summary>
            <param name="p">A point in space</param>
            <param name="s0">Start of line segment</param>
            <param name="s1">End of line segment</param>
            <returns>The interpolation parameter representing the point on the segment, with 0==s0, and 1==s1</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.ClosestPointOnSegment(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Get the closest point on a line segment.
            </summary>
            <param name="p">A point in space</param>
            <param name="s0">Start of line segment</param>
            <param name="s1">End of line segment</param>
            <returns>The interpolation parameter representing the point on the segment, with 0==s0, and 1==s1</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.ProjectOntoPlane(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Returns a non-normalized projection of the supplied vector onto a plane
            as described by its normal
            </summary>
            <param name="vector"></param>
            <param name="planeNormal">The normal that defines the plane.  Cannot be zero-length.</param>
            <returns>The component of the vector that lies in the plane</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.AlmostZero(UnityEngine.Vector3)">
            <summary>Is the vector within Epsilon of zero length?</summary>
            <param name="v"></param>
            <returns>True if the square magnitude of the vector is within Epsilon of zero</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.SignedAngle(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>Get a signed angle between two vectors</summary>
            <param name="from">Start direction</param>
            <param name="to">End direction</param>
            <param name="refNormal">This is needed in order to determine the sign.
            For example, if from an to lie on the XZ plane, then this would be the
            Y unit vector, or indeed any vector which, when dotted with Y unit vector,
            would give a positive result.</param>
            <returns>The signed angle between the vectors</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityVectorExtensions.SlerpWithReferenceUp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Vector3)">
            <summary>This is a slerp that mimics a camera operator's movement in that
            it chooses a path that avoids the lower hemisphere, as defined by
            the up param</summary>
            <param name="vA">First direction</param>
            <param name="vB">Second direction</param>
            <param name="t">Interpolation amoun t</param>
            <param name="up">Defines the up direction</param>
        </member>
        <member name="T:Cinemachine.Utility.UnityQuaternionExtensions">
            <summary>Extentions to the Quaternion class, usen in various places by Cinemachine</summary>
        </member>
        <member name="M:Cinemachine.Utility.UnityQuaternionExtensions.SlerpWithReferenceUp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single,UnityEngine.Vector3)">
            <summary>This is a slerp that mimics a camera operator's movement in that
            it chooses a path that avoids the lower hemisphere, as defined by
            the up param</summary>
            <param name="qA">First direction</param>
            <param name="qB">Second direction</param>
            <param name="t">Interpolation amoun t</param>
            <param name="up">Defines the up direction</param>
        </member>
        <member name="M:Cinemachine.Utility.UnityQuaternionExtensions.Normalized(UnityEngine.Quaternion)">
            <summary>Normalize a quaternion</summary>
            <param name="q"></param>
            <returns>The normalized quaternion.  Unit length is 1.</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityQuaternionExtensions.GetCameraRotationToTarget(UnityEngine.Quaternion,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Get the rotations, first about world up, then about (travelling) local right,
            necessary to align the quaternion's forward with the target direction.
            This represents the tripod head movement needed to look at the target.
            This formulation makes it easy to interpolate without introducing spurious roll.
            </summary>
            <param name="orient"></param>
            <param name="lookAtDir">The worldspace target direction in which we want to look</param>
            <param name="worldUp">Which way is up</param>
            <returns>Vector2.y is rotation about worldUp, and Vector2.x is second rotation,
            about local right.</returns>
        </member>
        <member name="M:Cinemachine.Utility.UnityQuaternionExtensions.ApplyCameraRotation(UnityEngine.Quaternion,UnityEngine.Vector2,UnityEngine.Vector3)">
            <summary>
            Apply rotations, first about world up, then about (travelling) local right.
            rot.y is rotation about worldUp, and rot.x is second rotation, about local right.
            </summary>
            <param name="orient"></param>
            <param name="rot">Vector2.y is rotation about worldUp, and Vector2.x is second rotation,
            about local right.</param>
            <param name="worldUp">Which way is up</param>
        </member>
        <member name="T:Cinemachine.Utility.UnityRectExtensions">
            <summary>Ad-hoc xxtentions to the Rect structure, used by Cinemachine</summary>
        </member>
        <member name="M:Cinemachine.Utility.UnityRectExtensions.Inflated(UnityEngine.Rect,UnityEngine.Vector2)">
            <summary>Inflate a rect</summary>
            <param name="r"></param>
            <param name="delta">x and y are added/subtracted fto/from the edges of
            the rect, inflating it in all directions</param>
            <returns>The inflated rect</returns>
        </member>
        <member name="T:Cinemachine.CinemachineExtension">
            <summary>
            Base class for a Cinemachine Virtual Camera extension module.
            Hooks into the Cinemachine Pipeline.
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineExtension.Epsilon">
            <summary>Useful constant for very small floats</summary>
        </member>
        <member name="P:Cinemachine.CinemachineExtension.VirtualCamera">
            <summary>Get the associated CinemachineVirtualCameraBase</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.Awake">
            <summary>Connect to virtual camera pipeline.
            Override implementations must call this base implementation</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.OnDestroy">
            <summary>Disconnect from virtual camera pipeline.
            Override implementations must call this base implementation</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.PostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>
            This callback will be called after the virtual camera has implemented
            each stage in the pipeline.  This method may modify the referenced state.
            If deltaTime less than 0, reset all state info and perform no damping. 
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.GetExtraState``1(Cinemachine.ICinemachineCamera)">
            <summary>Because extensions can be placed on manager cams and will in that
            case be called for all the vcam children, vcam-specific state information
            should be stored here.  Just define a class to hold your state info
            and use it exclusively when calling this.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineExtension.GetAllExtraStates``1">
            <summary>Ineffeicient method to get all extra state infor for all vcams.  
            Intended for Editor use only, not runtime!
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachinePathBase">
            <summary>Abstract base class for a world-space path,
            suitable for a camera dolly track.</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePathBase.m_Resolution">
            <summary>Path samples per waypoint</summary>
        </member>
        <member name="T:Cinemachine.CinemachinePathBase.Appearance">
            <summary>This class holds the settings that control how the path
            will appear in the editor scene view.  The path is not visible in the game view</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePathBase.m_Appearance">
            <summary>The settings that control how the path
            will appear in the editor scene view.</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.MinPos">
            <summary>The minimum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.MaxPos">
            <summary>The maximum value for the path position</summary>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.Looped">
            <summary>True if the path ends are joined to form a continuous loop</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.NormalizePos(System.Single)">
            <summary>Get a normalized path position, taking spins into account if looped</summary>
            <param name="pos">Position along the path</param>
            <returns>Normalized position, between MinPos and MaxPos</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluatePosition(System.Single)">
            <summary>Get a worldspace position of a point along the path</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space position of the point along at path at pos</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluateTangent(System.Single)">
            <summary>Get the tangent of the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space direction of the path tangent.
            Length of the vector represents the tangent strength</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluateOrientation(System.Single)">
            <summary>Get the orientation the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <returns>World-space orientation of the path</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.FindClosestPoint(UnityEngine.Vector3,System.Int32,System.Int32,System.Int32)">
            <summary>Find the closest point on the path to a given worldspace target point.</summary>
            <remarks>Performance could be improved by checking the bounding polygon of each segment,
            and only entering the best segment(s)</remarks>
            <param name="p">Worldspace target that we want to approach</param>
            <param name="startSegment">In what segment of the path to start the search.
            A Segment is a section of path between 2 waypoints.</param>
            <param name="searchRadius">How many segments on either side of the startSegment
            to search.  -1 means no limit, i.e. search the entire path</param>
            <param name="stepsPerSegment">We search a segment by dividing it into this many
            straight pieces.  The higher the number, the more accurate the result, but performance
            is proportionally slower for higher numbers</param>
            <returns>The position along the path that is closest to the target point.  
            The value is in Path Units, not Distance units.</returns>
        </member>
        <member name="T:Cinemachine.CinemachinePathBase.PositionUnits">
            <summary>How to interpret the Path Position</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePathBase.PositionUnits.PathUnits">
            <summary>Use PathPosition units, where 0 is first waypoint, 1 is second waypoint, etc</summary>
        </member>
        <member name="F:Cinemachine.CinemachinePathBase.PositionUnits.Distance">
            <summary>Use Distance Along Path.  Path will be sampled according to its Resolution
            setting, and a distance lookup table will be cached internally</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.MinUnit(Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get the minimum value, for the given unity type</summary>
            <param name="units">The uniot type</param>
            <returns>The minimum allowable value for this path</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.MaxUnit(Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get the maximum value, for the given unity type</summary>
            <param name="units">The uniot type</param>
            <returns>The maximum allowable value for this path</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.NormalizeUnit(System.Single,Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Normalize the unit, so that it lies between MinUmit and MaxUnit</summary>
            <param name="pos">The value to be normalized</param>
            <param name="units">The unit type</param>
            <returns>The normalized value of pos, between MinUnit and MaxUnit</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluatePositionAtUnit(System.Single,Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get a worldspace position of a point along the path</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <param name="units">The unit to use when interpreting the value of pos.</param>
            <returns>World-space position of the point along at path at pos</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluateTangentAtUnit(System.Single,Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get the tangent of the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <param name="units">The unit to use when interpreting the value of pos.</param>
            <returns>World-space direction of the path tangent.
            Length of the vector represents the tangent strength</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.EvaluateOrientationAtUnit(System.Single,Cinemachine.CinemachinePathBase.PositionUnits)">
            <summary>Get the orientation the curve at a point along the path.</summary>
            <param name="pos">Postion along the path.  Need not be normalized.</param>
            <param name="units">The unit to use when interpreting the value of pos.</param>
            <returns>World-space orientation of the path</returns>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.DistanceCacheSampleStepsPerSegment">
            <summary>When calculating the distance cache, sample the path this many 
            times between points</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.InvalidateDistanceCache">
            <summary>Call this if the path changes in such a way as to affect distances
            or other cached path elements</summary>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.DistanceCacheIsValid">
            <summary>See whether the distance cache is valid.  If it's not valid,
            then any call to GetPathLength() or GetPathPositionFromDistance() will
            trigger a potentially costly regeneration of the path distance cache</summary>
            <param name="stepsPerSegment">The number of steps to take between path points</param>
            <returns>Whether the cache is valid for this sampling rate</returns>
        </member>
        <member name="P:Cinemachine.CinemachinePathBase.PathLength">
            <summary>Get the length of the path in distance units.  
            If the distance cache is not valid, then calling this will 
            trigger a potentially costly regeneration of the path distance cache</summary>
            <returns>The length of the path in distance units, when sampled at this rate</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.NormalizePathDistance(System.Single)">
            <summary>Normalize a distance along the path based on the path length.  
            If the distance cache is not valid, then calling this will 
            trigger a potentially costly regeneration of the path distance cache</summary>
            <param name="distance">The distance to normalize</param>
            <returns>The normalized distance, ranging from 0 to path length</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.GetPathPositionFromDistance(System.Single)">
            <summary>Get the path position (in path units) corresponding to this distance along the path.  
            If the distance cache is not valid, then calling this will 
            trigger a potentially costly regeneration of the path distance cache</summary>
            <returns>The length of the path in distance units, when sampled at this rate</returns>
        </member>
        <member name="M:Cinemachine.CinemachinePathBase.GetPathDistanceFromPosition(System.Single)">
            <summary>Get the path position (in path units) corresponding to this distance along the path.  
            If the distance cache is not valid, then calling this will 
            trigger a potentially costly regeneration of the path distance cache</summary>
            <returns>The length of the path in distance units, when sampled at this rate</returns>
        </member>
        <member name="T:Cinemachine.LensSettingsPropertyAttribute">
            <summary>
            Property applied to LensSettings.  Used for custom drawing in the inspector.
            </summary>
        </member>
        <member name="T:Cinemachine.CinemachineBlendDefinitionPropertyAttribute">
            <summary>
            Property applied to CinemachineBlendDefinition.  Used for custom drawing in the inspector.
            </summary>
        </member>
        <member name="T:Cinemachine.SaveDuringPlayAttribute">
            <summary>
            Invoke play-mode-save for a class.  This class's fields will be scanned
            upon exiting play mode, and its property values will be applied to the scene object.
            This is a stopgap measure that will become obsolete once Unity implements
            play-mode-save in a more general way.
            </summary>
        </member>
        <member name="T:Cinemachine.NoSaveDuringPlayAttribute">
            <summary>
            Suppresses play-mode-save for a field.  Use it if the calsee has [SaveDuringPlay] 
            attribute but there are fields in the class that shouldn't be saved.
            </summary>
        </member>
        <member name="T:Cinemachine.TagFieldAttribute">
            <summary>Property field is a Tag.</summary>
        </member>
        <member name="T:Cinemachine.DocumentationSortingAttribute">
            <summary>
            Atrtribute to control the automatic generation of documentation.
            </summary>
        </member>
        <member name="T:Cinemachine.DocumentationSortingAttribute.Level">
            <summary>Refinement level of the documentation</summary>
        </member>
        <member name="F:Cinemachine.DocumentationSortingAttribute.Level.Undoc">
            <summary>Type is excluded from documentation</summary>
        </member>
        <member name="F:Cinemachine.DocumentationSortingAttribute.Level.API">
            <summary>Type is documented in the API reference</summary>
        </member>
        <member name="F:Cinemachine.DocumentationSortingAttribute.Level.UserRef">
            <summary>Type is documented in the highly-refined User Manual</summary>
        </member>
        <member name="P:Cinemachine.DocumentationSortingAttribute.SortOrder">
            <summary>Where this type appears in the manual.  Smaller number sort earlier.</summary>
        </member>
        <member name="P:Cinemachine.DocumentationSortingAttribute.Category">
            <summary>Refinement level of the documentation.  The more refined, the more is excluded.</summary>
        </member>
        <member name="M:Cinemachine.DocumentationSortingAttribute.#ctor(System.Single,Cinemachine.DocumentationSortingAttribute.Level)">
            <summary>Contructor with specific values</summary>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCameraBase">
             <summary>
             Base class for a Monobehaviour that represents a Virtual Camera within the Unity scene.
            
             This is intended to be attached to an empty Transform GameObject.
             Inherited classes can be either standalone virtual cameras such
             as CinemachineVirtualCamera, or meta-cameras such as
             CinemachineClearShot or CinemachineFreeLook.
            
             A CinemachineVirtualCameraBase exposes a Priority property.  When the behaviour is
             enabled in the game, the Virtual Camera is automatically placed in a queue
             maintained by the static CinemachineCore singleton.
             The queue is sorted by priority.  When a Unity camera is equipped with a
             CinemachineBrain behaviour, the brain will choose the camera
             at the head of the queue.  If you have multiple Unity cameras with CinemachineBrain
             behaviours (say in a split-screen context), then you can filter the queue by
             setting the culling flags on the virtual cameras.  The culling mask of the
             Unity Camera will then act as a filter for the brain.  Apart from this,
             there is nothing that prevents a virtual camera from controlling multiple
             Unity cameras simultaneously.
             </summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.CinemachineGUIDebuggerCallback">
            <summary>This is deprecated.  It is here to support the soon-to-be-removed
            Cinemachine Debugger in the Editor.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.m_ExcludedPropertiesInInspector">
            <summary>Inspector control - Use for hiding sections of the Inspector UI.</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.m_LockStageInInspector">
            <summary>Inspector control - Use for enabling sections of the Inspector UI.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.ValidatingStreamVersion">
            <summary>Version that was last streamed, for upgrading legacy</summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.m_Priority">
            <summary>The priority will determine which camera becomes active based on the
            state of other cameras and this camera.  Higher numbers have greater priority.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.AddPostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>
            A delegate to hook into the state calculation pipeline.
            This will be called after each pipeline stage, to allow others to hook into the pipeline.
            See CinemachineCore.Stage.
            </summary>
            <param name="d">The delegate to call.</param>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.RemovePostPipelineStageHook(Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate)">
            <summary>Remove a Pipeline stage hook callback.</summary>
            <param name="d">The delegate to remove.</param>
        </member>
        <member name="T:Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStageDelegate">
            <summary>
            A delegate to hook into the state calculation pipeline.
            This will be called after each pipeline stage, to allow other
            services to hook into the pipeline.
            See CinemachineCore.Stage.
            
            Parameters:
            
            * CinemachineVirtualCameraBase vcam: the virtual camera being updated
            * CinemachineCore.Stage stage: what stage in the pipeline has just been updated
            * ref CameraState newState: the current state of the vcam
            * float deltaTime: the frame timestep.  Less than 0 means "don't consider the previous frame"
            </summary>
        </member>
        <member name="F:Cinemachine.CinemachineVirtualCameraBase.OnPostPipelineStage">
            <summary>
            A delegate to hook into the state calculation pipeline.
            Implementaion must be sure to call this after each pipeline stage, to allow
            other services to hook into the pipeline.
            See CinemachineCore.Stage.
            </summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.InvokePostPipelineStageCallback(Cinemachine.CinemachineVirtualCameraBase,Cinemachine.CinemachineCore.Stage,Cinemachine.CameraState@,System.Single)">
            <summary>
            Invokes the PostPipelineStageDelegate for this camera, and up the hierarchy for all
            parent cameras (if any).
            </summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.Name">
            <summary>Get the name of the Virtual Camera.  Base implementation
            returns the owner GameObject's name.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.Description">
            <summary>Gets a brief debug description of this virtual camera, for use when displayiong debug info</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.Priority">
            <summary>Get the Priority of the virtual camera.  This determines its placement
            in the CinemachineCore's queue of eligible shots.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.VirtualCameraGameObject">
            <summary>The GameObject owner of the Virtual Camera behaviour.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.State">
            <summary>The CameraState object holds all of the information
            necessary to position the Unity camera.  It is the output of this class.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.LiveChildOrSelf">
            <summary>Just returns self.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.ParentCamera">
            <summary>Support for meta-virtual-cameras.  This is the situation where a
            virtual camera is in fact the public face of a private army of virtual cameras, which
            it manages on its own.  This method gets the VirtualCamera owner, if any.
            Private armies are implemented as Transform children of the parent vcam.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam a live child of this camera.  
            This base class implementation always returns false.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.LookAt">
            <summary>Get the LookAt target for the Aim component in the CinemachinePipeline.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.Follow">
            <summary>Get the Follow target for the Body component in the CinemachinePipeline.</summary>
        </member>
        <member name="P:Cinemachine.CinemachineVirtualCameraBase.PreviousStateIsValid">
            <summary>Set this to force the next update to ignore deltaTime and reset itself</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>Called by CinemachineCore at designated update time
            so the vcam can position itself and track its targets.  
            Do not call this method.  Let the framework do it at the appropriate time</summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>Notification that this virtual camera is going live.
            Base class implementationmust be called by any overridden method.</summary>
            <param name="fromCam">The camera being deactivated.  May be null.</param>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than or equal to 0)</param>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.Start">
            <summary>Base class implementation does nothing.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnDestroy">
            <summary>Base class implementation removes the virtual camera from the priority queue.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnValidate">
            <summary>Enforce bounds for fields, when changed in inspector.  
            Call base class implementation at the beginning of overridden method.
            After base method is called, ValidatingStreamVersion will be valid.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnEnable">
            <summary>Base class implementation adds the virtual camera from the priority queue.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnDisable">
            <summary>Base class implementation makes sure the priority queue remains up-to-date.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.Update">
            <summary>Base class implementation makes sure the priority queue remains up-to-date.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnTransformParentChanged">
            <summary>Base class implementation makes sure the priority queue remains up-to-date.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.OnGUI">
            <summary>Support for the deprecated CinemachineDebugger.</summary>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.ResolveLookAt(UnityEngine.Transform)">
            <summary>Returns this vcam's LookAt target, or if that is null, will retrun
            the parent vcam's LookAt target.</summary>
            <param name="localLookAt">This vcam's LookAt value.</param>
            <returns>The same value, or the parent's if null and a parent exists.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.ResolveFollow(UnityEngine.Transform)">
            <summary>Returns this vcam's Follow target, or if that is null, will retrun
            the parent vcam's Follow target.</summary>
            <param name="localFollow">This vcam's Follow value.</param>
            <returns>The same value, or the parent's if null and a parent exists.</returns>
        </member>
        <member name="M:Cinemachine.CinemachineVirtualCameraBase.MoveToTopOfPrioritySubqueue">
            <summary>When multiple virtual cameras have the highest priority, there is
            sometimes the need to push one to the top, making it the current Live camera if 
            it shares the highest priority in the queue with its peers.  
            
            This happens automatically when a 
            new vcam is enabled: the most recent one goes to the top of the priority subqueue.  
            Use this method to push a vcam to the top of its priority peers.  
            If it and its peers share the highest priority, then this vcam will become Live.</summary>
        </member>
        <member name="T:Cinemachine.ICinemachineCamera">
            <summary>
            An abstract representation of a virtual camera which lives within the Unity scene
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.Name">
            <summary>
            Gets the name of this virtual camera. For use when deciding how to blend
            to or from this camera
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.Description">
            <summary>
            Gets a brief debug description of this virtual camera, for use when displayiong debug info
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.Priority">
            <summary>
            Gets the priority of this <c>ICinemachineCamera</c>. The virtual camera
            will be inserted into the global priority stack based on this value.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.LookAt">
            <summary>
            The thing the camera wants to look at (aim).  May be null.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.Follow">
            <summary>
            The thing the camera wants to follow (moving camera).  May be null.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.State">
            <summary>
            Camera state at the current time.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.VirtualCameraGameObject">
            <summary>
            Gets the virtual camera game attached to this class.
            </summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.LiveChildOrSelf">
            <summary>For cameras that implement child cameras, return the live child,
            otherwise, just returns self.</summary>
        </member>
        <member name="P:Cinemachine.ICinemachineCamera.ParentCamera">
            <summary>
            For cameras that implement child cameras, returns the parent vcam, otherwise null.
            </summary>
        </member>
        <member name="M:Cinemachine.ICinemachineCamera.IsLiveChild(Cinemachine.ICinemachineCamera)">
            <summary>Check whether the vcam is a live child of this camera.</summary>
            <param name="vcam">The Virtual Camera to check</param>
            <returns>True if the vcam is currently actively influencing the state of this vcam</returns>
        </member>
        <member name="M:Cinemachine.ICinemachineCamera.UpdateCameraState(UnityEngine.Vector3,System.Single)">
            <summary>
            Updates this Cinemachine Camera. For an active camera this should be
            called once and only once each frame.  To guarantee this, you should never
            call this method directly.  Always use
            CinemachineCore.UpdateVirtualCamera(ICinemachineCamera, float), which
            has protection against multiple calls per frame.
            </summary>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="M:Cinemachine.ICinemachineCamera.OnTransitionFromCamera(Cinemachine.ICinemachineCamera,UnityEngine.Vector3,System.Single)">
            <summary>
            Notification that a new camera is being activated.  This is sent to the
            currently active camera.  Both may be active simultaneously for a while, if blending.
            </summary>
            <param name="fromCam">The camera being deactivated.  May be null.</param>
            <param name="worldUp">Default world Up, set by the CinemachineBrain</param>
            <param name="deltaTime">Delta time for time-based effects (ignore if less than 0)</param>
        </member>
        <member name="T:Cinemachine.LensSettings">
            <summary>
            Describes the FOV and clip planes for a camera.  This generally mirrors the Unity Camera's 
            lens settings, and will be used to drive the Unity camera when the vcam is active.
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.Default">
            <summary>Default Lens Settings</summary>
        </member>
        <member name="F:Cinemachine.LensSettings.FieldOfView">
            <summary>
            This is the camera view in vertical degrees. For cinematic people, a 50mm lens
            on a super-35mm sensor would equal a 19.6 degree FOV
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.OrthographicSize">
            <summary>
            When using an orthographic camera, this defines the height, in world 
            co-ordinates, of the camera view.
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.NearClipPlane">
            <summary>
            The near clip plane for this LensSettings
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.FarClipPlane">
            <summary>
            The far clip plane for this LensSettings
            </summary>
        </member>
        <member name="F:Cinemachine.LensSettings.Dutch">
            <summary>
            The dutch (tilt) to be applied to the camera. In degrees
            </summary>
        </member>
        <member name="P:Cinemachine.LensSettings.Orthographic">
            <summary>
            This is set every frame by the virtual camera, based on the value found in the 
            currently associated Unity camera
            </summary>
        </member>
        <member name="P:Cinemachine.LensSettings.Aspect">
            <summary>
            This is set every frame by the virtual camera, based on the value 
            found in the currently associated Unity camera
            </summary>
        </member>
        <member name="M:Cinemachine.LensSettings.FromCamera(UnityEngine.Camera)">
            <summary>
            Creates a new LensSettings, copying the values from the 
            supplied Camera
            </summary>
            <param name="fromCamera">The Camera from which the FoV, near 
            and far clip planes will be copied.</param>
        </member>
        <member name="M:Cinemachine.LensSettings.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Single)">
            <summary>
            Explicit constructor for this LensSettings
            </summary>
            <param name="fov">The Vertical field of view</param>
            <param name="orthographicSize">If orthographic, this is the half-height of the screen</param>
            <param name="nearClip">The near clip plane</param>
            <param name="farClip">The far clip plane</param>
            <param name="dutch">Camera roll, in degrees.  This is applied at the end 
            <param name="ortho">Whether the lens is orthographic</param>
            <param name="aspect">The aspect ratio of the lens  Width/height</param>
            after shot composition.</param>
        </member>
        <member name="M:Cinemachine.LensSettings.Lerp(Cinemachine.LensSettings,Cinemachine.LensSettings,System.Single)">
            <summary>
            Linearly blends the fields of two LensSettings and returns the result
            </summary>
            <param name="lensA">The LensSettings to blend from</param>
            <param name="lensB">The LensSettings to blend to</param>
            <param name="t">The interpolation value. Internally clamped to the range [0,1]</param>
            <returns>Interpolated settings</returns>
        </member>
        <member name="M:Cinemachine.LensSettings.Validate">
            <summary>Make sure lens settings are sane.  Call this from OnValidate().</summary>
        </member>
        <member name="T:Cinemachine.NoiseSettings">
            <summary>
            This is an asset that defines a noise profile.  A noise profile is the 
            shape of the noise as a function of time.  You can build arbitrarily complex shapes by
            combining different base perlin noise frequencies at different amplitudes.
            
            The frequencies and amplitudes should be chosen with care, to ensure an interesting
            noise quality that is not obviously repetitive.
            
            As a mathematical side-note, any arbitrary periodic curve can be broken down into a 
            series of fixed-amplitude sine-waves added together.  This is called fourier decomposition,
            and is the basis of much signal processing.  It doesn't really have much to do with this
            asset, but it's super interesting!
            </summary>
        </member>
        <member name="T:Cinemachine.NoiseSettings.NoiseParams">
            <summary>
            Describes the behaviour for a channel of noise
            </summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.NoiseParams.Amplitude">
            <summary>The amplitude of the noise for this channel.  Larger numbers vibrate higher</summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.NoiseParams.Frequency">
            <summary>The frequency of noise for this channel.  Higher magnitudes vibrate faster</summary>
        </member>
        <member name="T:Cinemachine.NoiseSettings.TransformNoiseParams">
            <summary>
            Contains the behaviour of noise for the noise module for all 3 cardinal axes of the camera
            </summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.TransformNoiseParams.X">
            <summary>Noise definition for X-axis</summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.TransformNoiseParams.Y">
            <summary>Noise definition for Y-axis</summary>
        </member>
        <member name="F:Cinemachine.NoiseSettings.TransformNoiseParams.Z">
            <summary>Noise definition for Z-axis</summary>
        </member>
        <member name="P:Cinemachine.NoiseSettings.PositionNoise">
            <summary>
            Gets the array of positional noise channels for this <c>NoiseSettings</c>
            </summary>
        </member>
        <member name="P:Cinemachine.NoiseSettings.OrientationNoise">
            <summary>
            Gets the array of orientation noise channels for this <c>NoiseSettings</c>
            </summary>
        </member>
        <member name="M:Cinemachine.NoiseSettings.CopyFrom(Cinemachine.NoiseSettings)">
            <summary>Clones the contents of the other asset into this one</summary>
        </member>
        <member name="T:Cinemachine.PostFX.CinemachinePostProcessing">
            <summary>
            This behaviour is a liaison between Cinemachine with the Post-Processing v2 module.  You must 
            have the Post-Processing V2 stack asset store package installed in order to use this behaviour.
            
            As a component on the Virtual Camera, it holds
            a Post-Processing Profile asset that will be applied to the Unity camera whenever 
            the Virtual camera is live.  It also has the optional functionality of animating
            the Focus Distance and DepthOfField properties of the Camera State, and
            applying them to the current Post-Processing profile, provided that profile has a
            DepthOfField effect that is enabled.
            </summary>
        </member>
        <member name="P:Cinemachine.PostFX.CinemachinePostProcessing.IsValid">
            <summary>True if the profile is enabled and nontrivial</summary>
        </member>
        <member name="M:Cinemachine.PostFX.CinemachinePostProcessing.InvalidateCachedProfile">
            <summary>Called by the editor when the shared asset has been edited</summary>
        </member>
        <member name="M:Cinemachine.PostFX.CinemachinePostProcessing.InitializeModule">
            <summary>Internal method called by editor module</summary>
        </member>
        <member name="T:RootMotion.FinalIK.BipedIK">
            <summary>
            %IK system for standard biped characters that is designed to replicate and enhance the behaviour of the Unity's built-in character %IK setup.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIK.references">
            <summary>
            References to character bones.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIK.solvers">
            <summary>
            The %IK solvers.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.GetIKPositionWeight(UnityEngine.AvatarIKGoal)">
            <summary>
            Gets the %IK position weight.
            </summary>
            <param name='goal'>
            %IK Goal.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.GetIKRotationWeight(UnityEngine.AvatarIKGoal)">
            <summary>
            Gets the %IK rotation weight.
            </summary>
            <param name='goal'>
            IK Goal.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.SetIKPositionWeight(UnityEngine.AvatarIKGoal,System.Single)">
            <summary>
            Sets the %IK position weight.
            </summary>
            <param name='goal'>
            %IK Goal.
            </param>
            <param name='weight'>
            Weight.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.SetIKRotationWeight(UnityEngine.AvatarIKGoal,System.Single)">
            <summary>
            Sets the %IK rotation weight.
            </summary>
            <param name='goal'>
            %IK Goal.
            </param>
            <param name='weight'>
            Weight.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.SetIKPosition(UnityEngine.AvatarIKGoal,UnityEngine.Vector3)">
            <summary>
            Sets the %IK position.
            </summary>
            <param name='goal'>
            %IK Goal.
            </param>
            <param name='IKPosition'>
            Position.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.SetIKRotation(UnityEngine.AvatarIKGoal,UnityEngine.Quaternion)">
            <summary>
            Sets the %IK rotation.
            </summary>
            <param name='goal'>
            %IK Goal.
            </param>
            <param name='IKRotation'>
            Rotation.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.GetIKPosition(UnityEngine.AvatarIKGoal)">
            <summary>
            Gets the %IK position.
            </summary>
            <param name='goal'>
            %IK Goal.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.GetIKRotation(UnityEngine.AvatarIKGoal)">
            <summary>
            Gets the %IK rotation.
            </summary>
            <param name='goal'>
            %IK Goal.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.SetLookAtWeight(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the look at weight.
            </summary>
            <param name='weight'>
            Master Weight.
            </param>
            <param name='bodyWeight'>
            Body weight.
            </param>
            <param name='headWeight'>
            Head weight.
            </param>
            <param name='eyesWeight'>
            Eyes weight.
            </param>
            <param name='clampWeight'>
            Clamp weight for body and head.
            </param>
            <param name='clampWeightEyes'>
            Clamp weight for eyes.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.SetLookAtPosition(UnityEngine.Vector3)">
            <summary>
            Sets the look at target.
            </summary>
            <param name='lookAtPosition'>
            Look at position.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.SetSpinePosition(UnityEngine.Vector3)">
            <summary>
            Sets the spine %IK position.
            </summary>
            <param name='spinePosition'>
            Spine %IK position.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.SetSpineWeight(System.Single)">
            <summary>
            Sets the spine weight.
            </summary>
            <param name='weight'>
            Weight.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.GetGoalIK(UnityEngine.AvatarIKGoal)">
            <summary>
            Gets the limb solver for the %IK Goal.
            </summary>
            <returns>
            The solver.
            </returns>
            <param name='goal'>
            %IK Goal.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.InitiateBipedIK">
            <summary>
            (Re)Initiates the biped IK solvers.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.UpdateBipedIK">
            <summary>
            Updating BipedIK
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.BipedIK.LogWarning(System.String)">
            <summary>
            Logs the warning if no other warning has beed logged in this session.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.BipedIKSolvers">
            <summary>
            BipedIK solver collection.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIKSolvers.leftFoot">
            <summary>
            The left foot
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIKSolvers.rightFoot">
            <summary>
            The right foot.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIKSolvers.leftHand">
            <summary>
            The left hand.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIKSolvers.rightHand">
            <summary>
            The right hand.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIKSolvers.spine">
            <summary>
            The spine.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIKSolvers.lookAt">
            <summary>
            The Look At %IK.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIKSolvers.aim">
            <summary>
            The Aim %IK. Rotates the spine to aim a transform's forward towards the target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.BipedIKSolvers.pelvis">
            <summary>
            %Constraints for manipulating the character's pelvis.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.BipedIKSolvers.limbs">
            <summary>
            Gets the array containing all the limbs.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.BipedIKSolvers.ikSolvers">
            <summary>
            Gets the array containing all %IK solvers.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Constraint">
            <summary>
            The base abstract class for all Transform constraints.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraint.transform">
            <summary>
            The transform to constrain.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraint.weight">
            <summary>
            %Constraint weight.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Constraint.isValid">
            <summary>
            Gets a value indicating whether this <see cref="T:RootMotion.FinalIK.Constraint"/> is valid.
            </summary>
            <value>
            <c>true</c> if is valid; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:RootMotion.FinalIK.Constraint.UpdateConstraint">
            <summary>
            Updates the constraint.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.ConstraintPosition">
            <summary>
            %Constraints to position in world space.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.ConstraintPosition.position">
            <summary>
            The target position.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.ConstraintPositionOffset">
            <summary>
            Offsets the transform from it's (animated) position.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.ConstraintPositionOffset.offset">
            <summary>
            The position offset in world space.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.ConstraintRotation">
            <summary>
            %Constraints to rotation in world space
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.ConstraintRotation.rotation">
            <summary>
            The target rotation.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.ConstraintRotationOffset">
            <summary>
            Offsets the transform from it's (animated) rotation
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.ConstraintRotationOffset.offset">
            <summary>
            The rotation offset in world space.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Constraints">
            <summary>
            Contains and manages a set of constraints.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraints.transform">
            <summary>
            The transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraints.target">
            <summary>
            The target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraints.positionOffset">
            <summary>
            The position offset.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraints.position">
            <summary>
            The position to lerp to by positionWeight
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraints.positionWeight">
            <summary>
            The weight of lerping to position
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraints.rotationOffset">
            <summary>
            The rotation offset.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraints.rotation">
            <summary>
            The rotation to slerp to by rotationWeight
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Constraints.rotationWeight">
            <summary>
            The weight of slerping to rotation
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Constraints.IsValid">
            <summary>
            Determines whether this instance is valid.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Constraints.Initiate(UnityEngine.Transform)">
            <summary>
            Initiate to the specified transform.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Constraints.Update">
            <summary>
            Updates the constraints.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Finger">
            <summary>
            Contains a LimbIK solver and some additional logic to handle the finger.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Finger.weight">
            <summary>
            Master Weight for the finger.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Finger.rotationWeight">
            <summary>
            The weight of rotating the finger tip and bending the finger to the target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Finger.bone1">
            <summary>
            The first bone of the finger.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Finger.bone2">
            <summary>
            The second bone of the finger.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Finger.bone3">
            <summary>
            The (optional) third bone of the finger. This can be ignored for thumbs.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Finger.tip">
            <summary>
            The fingertip object. If your character doesn't have tip bones, you can create an empty GameObject and parent it to the last bone in the finger. Place it to the tip of the finger.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Finger.target">
            <summary>
            The IK target (optional, can use IKPosition and IKRotation directly).
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Finger.initiated">
            <summary>
            Has the finger properly initiated (in play mode only)?
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Finger.IKPosition">
            <summary>
            Gets or sets the IK target position if target is not used.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Finger.IKRotation">
            <summary>
            Gets or sets the IK target rotation if target is not used.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Finger.IsValid(System.String@)">
            <summary>
            Is this finger setup valid?
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FingerRig">
            <summary>
            Handles IK for a number of Fingers with 3-4 joints.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FingerRig.weight">
            <summary>
            The master weight for all fingers.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FingerRig.fingers">
            <summary>
            The array of Fingers.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.FingerRig.initiated">
            <summary>
            Has the rig properly initiated (in play mode only)?
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.FingerRig.IsValid(System.String@)">
            <summary>
            Is this rig valid?
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.FingerRig.AutoDetect">
            <summary>
            Attempts to automatically fill in the Finger bones.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.FingerRig.AddFinger(UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Adds a finger in run-time.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.FingerRig.RemoveFinger(System.Int32)">
            <summary>
            Removes a finger in runtime.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Grounder">
            <summary>
            Dedicated abstrac base component for the Grounding solver.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounder.weight">
            <summary>
            The master weight. Use this to fade in/out the grounding effect.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounder.solver">
            <summary>
            The %Grounding solver. Not to confuse with IK solvers.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Grounder.GrounderDelegate">
            <summary>
            Delegate for Grounder events.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounder.OnPreGrounder">
            <summary>
            Called before the Grounder updates it's solver.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounder.OnPostGrounder">
            <summary>
            Called after the Grounder has updated it's solver and before the IK is applied.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Grounder.ResetPosition">
            <summary>
            Resets this Grounder so characters can be teleported instananeously.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.GrounderBipedIK">
            <summary>
            Grounding for BipedIK characters.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderBipedIK.ik">
            <summary>
            The BipedIK componet.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderBipedIK.spineBend">
            <summary>
            The amount of spine bending towards upward slopes.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderBipedIK.spineSpeed">
            <summary>
            The interpolation speed of spine bending.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.GrounderFBBIK">
            <summary>
            Grounding for FBBIK characters.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.GrounderFBBIK.SpineEffector">
            <summary>
            Contains the bending weights for an effector.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderFBBIK.SpineEffector.effectorType">
            <summary>
            The type of the effector.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderFBBIK.SpineEffector.horizontalWeight">
            <summary>
            The weight of horizontal bend offset towards the slope..
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderFBBIK.SpineEffector.verticalWeight">
            <summary>
            The vertical bend offset weight.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.GrounderFBBIK.SpineEffector.#ctor(RootMotion.FinalIK.FullBodyBipedEffector,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="!:RootMotion.FinalIK.GrounderFBBIK+SpineEffector"/> class.
            </summary>
            <param name="effectorType">Effector type.</param>
            <param name="horizontalWeight">Horizontal weight.</param>
            <param name="verticalWeight">Vertical weight.</param>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderFBBIK.ik">
            <summary>
            Reference to the FBBIK componet.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderFBBIK.spineBend">
            <summary>
            The amount of spine bending towards upward slopes.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderFBBIK.spineSpeed">
            <summary>
            The interpolation speed of spine bending.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderFBBIK.spine">
            <summary>
            The spine bending effectors.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.GrounderIK">
            <summary>
            Grounding for LimbIK, CCD and/or FABRIK solvers.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderIK.legs">
            <summary>
            The leg %IK componets (can be any type of IK component).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderIK.pelvis">
            <summary>
            The pelvis transform. Common ancestor of all the legs.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderIK.characterRoot">
            <summary>
            The root Transform of the character, with the rigidbody and the collider.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderIK.rootRotationWeight">
            <summary>
            The weight of rotating the character root to the ground normal (range: 0 - 1).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderIK.rootRotationSpeed">
            <summary>
            The speed of rotating the character root to the ground normal (range: 0 - inf).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderIK.maxRootRotationAngle">
            <summary>
            The maximum angle of root rotation (range: 0 - 90).
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.GrounderQuadruped">
            <summary>
            Grounding for LimbIK, CCD and/or FABRIK solvers.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.forelegSolver">
            <summary>
            The %Grounding solver for the forelegs.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.rootRotationWeight">
            <summary>
            The weight of rotating the character root to the ground angle (range: 0 - 1).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.minRootRotation">
            <summary>
            The maximum angle of rotating the quadruped downwards (going downhill, range: -90 - 0).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.maxRootRotation">
            <summary>
            The maximum angle of rotating the quadruped upwards (going uphill, range: 0 - 90).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.rootRotationSpeed">
            <summary>
            The speed of interpolating the character root rotation (range: 0 - inf).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.maxLegOffset">
            <summary>
            The maximum IK offset for the legs (range: 0 - inf).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.maxForeLegOffset">
            <summary>
            The maximum IK offset for the forelegs (range: 0 - inf).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.maintainHeadRotationWeight">
            <summary>
            The weight of maintaining the head's rotation as it was before solving the Grounding (range: 0 - 1).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.characterRoot">
            <summary>
            The root Transform of the character, with the rigidbody and the collider.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.pelvis">
            <summary>
            The pelvis transform. Common ancestor of both legs and the spine.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.lastSpineBone">
            <summary>
            The last bone in the spine that is the common parent for both forelegs.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.head">
            <summary>
            The head (optional, if you intend to maintain it's rotation).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.legs">
            <summary>
            %IK componets of the hindlegs. Can be any type of IK components.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.forelegs">
            <summary>
            %IK components for the forelegs. Can be any type of IK components.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderQuadruped.gravity">
            <summary>
            When using GrounderQuadruped on a spherical object, update this vector to always point towards the center of that object.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.GrounderVRIK">
            <summary>
            Grounding for FBBIK characters.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.GrounderVRIK.ik">
            <summary>
            Reference to the VRIK componet.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Grounding">
            <summary>
            Foot placement system.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Grounding.Quality">
            <summary>
            The raycasting quality. Fastest is a single raycast per foot, Simple is three raycasts, Best is one raycast and a capsule cast per foot.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.layers">
            <summary>
            Layers to ground the character to. Make sure to exclude the layer of the character controller.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.maxStep">
            <summary>
            Max step height. Maximum vertical distance of Grounding from the root of the character.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.heightOffset">
            <summary>
            The height offset of the root.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.footSpeed">
            <summary>
            The speed of moving the feet up/down.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.footRadius">
            <summary>
            CapsuleCast radius. Should match approximately with the size of the feet.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.footCenterOffset">
            <summary>
            Offset of the foot center along character forward axis.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.prediction">
            <summary>
            Amount of velocity based prediction of the foot positions.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.footRotationWeight">
            <summary>
            Weight of rotating the feet to the ground normal offset.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.footRotationSpeed">
            <summary>
            Speed of slerping the feet to their grounded rotations.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.maxFootRotationAngle">
            <summary>
            Max Foot Rotation Angle, Max angular offset from the foot's rotation (Reasonable range: 0-90 degrees).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.rotateSolver">
            <summary>
            If true, solver will rotate with the character root so the character can be grounded for example to spherical planets. 
            For performance reasons leave this off unless needed.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.pelvisSpeed">
            <summary>
            The speed of moving the character up/down.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.pelvisDamper">
            <summary>
            Used for smoothing out vertical pelvis movement (range 0 - 1).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.lowerPelvisWeight">
            <summary>
            The weight of lowering the pelvis to the lowest foot.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.liftPelvisWeight">
            <summary>
            The weight of lifting the pelvis to the highest foot. This is useful when you don't want the feet to go too high relative to the body when crouching.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.rootSphereCastRadius">
            <summary>
            The radius of the spherecast from the root that determines whether the character root is grounded.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.quality">
            <summary>
            The raycasting quality. Fastest is a single raycast per foot, Simple is three raycasts, Best is one raycast and a capsule cast per foot.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.legs">
            <summary>
            The %Grounding legs.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.pelvis">
            <summary>
            The %Grounding pelvis.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.isGrounded">
            <summary>
            Gets a value indicating whether any of the legs are grounded
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.root">
            <summary>
            The root Transform
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.rootHit">
            <summary>
            Ground height at the root position.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.rootGrounded">
            <summary>
            Is the RaycastHit from the root grounded?
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Grounding.GetRootHit(System.Single)">
            <summary>
            Raycasts or sphereCasts to find the root ground point. Distance of the Ray/Sphere cast is maxDistanceMlp x maxStep. Use this instead of rootHit if the Grounder is weighed out/disabled and not updated.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Grounding.IsValid(System.String@)">
            <summary>
            Gets a value indicating whether this <see cref="T:RootMotion.FinalIK.Grounding"/> is valid.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Grounding.Initiate(UnityEngine.Transform,UnityEngine.Transform[])">
            <summary>
            Initiate the %Grounding as an integrated solver by providing the root Transform, leg solvers, pelvis Transform and spine solver.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Grounding.Update">
            <summary>
            Updates the Grounding.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Grounding.Leg">
            <summary>
            The %Grounding %Leg.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.Leg.isGrounded">
            <summary>
            Returns true distance from foot to ground is less that maxStep
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.Leg.IKPosition">
            <summary>
            Gets the current IK position of the foot.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Grounding.Leg.rotationOffset">
            <summary>
            Gets the current rotation offset of the foot.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.Leg.initiated">
            <summary>
            Returns true, if the leg is valid and initiated
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.Leg.heightFromGround">
            <summary>
            The height of foot from ground.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.Leg.velocity">
            <summary>
            Velocity of the foot
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.Leg.transform">
            <summary>
            Gets the foot Transform.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.Leg.IKOffset">
            <summary>
            Gets the current IK offset.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Grounding.Pelvis">
            <summary>
            The %Grounding %Pelvis.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.Pelvis.IKOffset">
            <summary>
            Offset of the pelvis as a Vector3.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Grounding.Pelvis.heightOffset">
            <summary>
            Scalar vertical offset of the pelvis.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.AimIK">
            <summary>
            Aim %IK solver component.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.AimIK.solver">
            <summary>
            The Aim %IK solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.CCDIK">
            <summary>
            CCD (Cyclic Coordinate Descent) %IK solver component.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.CCDIK.solver">
            <summary>
            The CCD %IK solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FABRIK">
            <summary>
            Forward and Backward Reaching %IK solver component.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FABRIK.solver">
            <summary>
            The %FABRIK solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FABRIKRoot">
            <summary>
            %IK system for multiple branched %FABRIK chains.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FABRIKRoot.solver">
            <summary>
            The %FABRIKRoot solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FullBodyBipedIK">
            <summary>
            Full Body %IK System designed specifically for bipeds
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FullBodyBipedIK.references">
            <summary>
            The biped definition. Don't change refences directly in runtime, use SetReferences(BipedReferences references) instead.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FullBodyBipedIK.solver">
            <summary>
            The FullBodyBiped %IK solver.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.FullBodyBipedIK.SetReferences(RootMotion.BipedReferences,UnityEngine.Transform)">
            <summary>
            Sets the solver to new biped references.
            </summary>
            /// <param name="references">Biped references.</param>
            <param name="rootNode">Root node. if null, will try to detect the root node bone automatically. </param>
        </member>
        <member name="M:RootMotion.FinalIK.FullBodyBipedIK.ReferencesError(System.String@)">
            <summary>
            Checks the biped references for errors. Returns true if error found.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.FullBodyBipedIK.ReferencesWarning(System.String@)">
            <summary>
            Check for possible warnings with the biped references setup. Returns true if warning found. The solver can still run, but probably not how you expected.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IK">
            <summary>
            Base abstract class for %IK solver components.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IK.GetIKSolver">
            <summary>
            Gets the %IK component's solver as IKSolver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKExecutionOrder">
            <summary>
            Manages the execution order of IK components.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKExecutionOrder.IKComponents">
            <summary>
            The IK components, assign in the order in which you wish to update them.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.LegIK.solver">
            <summary>
            The Leg %IK solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.LimbIK">
            <summary>
            %IK component for IKSolverLimb.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.LimbIK.solver">
            <summary>
            The Limb %IK solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.LookAtIK">
            <summary>
            Rotates a hierarchy of bones to face a target
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.LookAtIK.solver">
            <summary>
            The LookAt %IK solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.TrigonometricIK">
            <summary>
            Analytic %IK algorithm based on the law of cosines
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.TrigonometricIK.solver">
            <summary>
            The Trigonometric %IK solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.VRIK">
            <summary>
            A full-body IK solver designed specifically for a VR HMD and hand controllers.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.VRIK.References">
            <summary>
            VRIK-specific definition of a humanoid biped.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.VRIK.References.GetTransforms">
            <summary>
            Returns an array of all the Transforms in the definition.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.VRIK.References.isFilled">
            <summary>
            Returns true if all required Transforms have been assigned (shoulder, toe and neck bones are optional).
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.VRIK.References.isEmpty">
            <summary>
            Returns true if none of the Transforms have been assigned.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.VRIK.References.AutoDetectReferences(UnityEngine.Transform,RootMotion.FinalIK.VRIK.References@)">
            <summary>
            Auto-detects VRIK references. Works with a Humanoid Animator on the root gameobject only.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.VRIK.references">
            <summary>
            The biped definition.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.VRIK.solver">
            <summary>
            The solver.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.VRIK.AutoDetectReferences">
            <summary>
            Auto-detects bone references for this VRIK. Works with a Humanoid Animator on the gameobject only.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.VRIK.GuessHandOrientations">
            <summary>
            Fills in arm wristToPalmAxis and palmToThumbAxis.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FABRIKChain">
            <summary>
            Branch of FABRIK components in the FABRIKRoot hierarchy.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FABRIKChain.ik">
            <summary>
            The FABRIK component.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FABRIKChain.pull">
            <summary>
            Parent pull weight.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FABRIKChain.pin">
            <summary>
            Resistance to being pulled by child chains.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FABRIKChain.children">
            <summary>
            The child chain indexes.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.FABRIKChain.IsValid(System.String@)">
            <summary>
            Checks whether this FABRIKChain is valid.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FBBIKArmBending">
            <summary>
            Calculates bending direction and hand rotations for a FBBIK rig for VR hand controllers. 
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FBBIKHeadEffector">
            <summary>
            Head effector for FBBIK.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FBIKChain">
            <summary>
            A chain of bones in IKSolverFullBody.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FBIKChain.ChildConstraint">
            <summary>
            Linear constraint between child chains of a FBIKChain.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.ChildConstraint.pushElasticity">
            <summary>
            The push elasticity.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.ChildConstraint.pullElasticity">
            <summary>
            The pull elasticity.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.ChildConstraint.bone1">
            <summary>
            The first bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.ChildConstraint.bone2">
            <summary>
            The second bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.pin">
            <summary>
            The pin weight. If closer to 1, the chain will be less influenced by child chains.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.pull">
            <summary>
            The weight of pulling the parent chain.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.push">
            <summary>
            The weight of the end-effector pushing the shoulder/thigh when the end-effector is close to it.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.pushParent">
            <summary>
            The amount of push force transferred to the parent (from hand or foot to the body).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.reach">
            <summary>
            Only used in 3 segmented chains, pulls the first node closer to the third node.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.reachSmoothing">
            <summary>
            Smoothing the effect of the Reach with the expense of some accuracy.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.pushSmoothing">
            <summary>
            Smoothing the effect of the Push.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.nodes">
            <summary>
            The nodes in this chain.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.children">
            <summary>
            The child chains.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.childConstraints">
            <summary>
            The child constraints are used for example for fixing the distance between left upper arm and right upper arm
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.FBIKChain.bendConstraint">
            <summary>
            Gets the bend constraint (if this chain has 3 segments).
            </summary>
            <value>The bend constraint.</value>
        </member>
        <member name="T:RootMotion.FinalIK.IKConstraintBend">
            <summary>
            %Constraint used for fixing bend direction of 3-segment node chains in a node based %IK solver. 
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKConstraintBend.bone1">
            <summary>
            The first bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKConstraintBend.bone2">
            <summary>
            The second (bend) bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKConstraintBend.bone3">
            <summary>
            The third bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKConstraintBend.bendGoal">
            <summary>
            The bend goal Transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKConstraintBend.direction">
            <summary>
            The bend direction.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKConstraintBend.rotationOffset">
            <summary>
            The bend rotation offset.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKConstraintBend.weight">
            <summary>
            The weight. If weight is 1, will override effector rotation and the joint will be rotated at the direction. This enables for direct manipulation of the bend direction independent of effector rotation.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKConstraintBend.IsValid(RootMotion.FinalIK.IKSolverFullBody,RootMotion.Warning.Logger)">
            <summary>
            Determines whether this IKConstraintBend is valid.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKEffector">
            <summary>
             Effector for manipulating node based %IK solvers.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKEffector.GetNode(RootMotion.FinalIK.IKSolverFullBody)">
            <summary>
            Gets the main node.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKEffector.bone">
            <summary>
            The node transform used by this effector.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKEffector.target">
            <summary>
            The target Transform (optional, you can use just the position and rotation instead).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKEffector.positionWeight">
            <summary>
            The position weight.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKEffector.rotationWeight">
            <summary>
            The rotation weight.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKEffector.position">
            <summary>
            The effector position in world space.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKEffector.rotation">
            <summary>
            The effector rotation relative to default rotation in world space.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKEffector.positionOffset">
            <summary>
            The position offset in world space. positionOffset will be reset to Vector3.zero each frame after the solver is complete.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKEffector.isEndEffector">
            <summary>
            Is this the last effector of a node chain?
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKEffector.effectChildNodes">
            <summary>
            If false, child nodes will be ignored by this effector (if it has any).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKEffector.maintainRelativePositionWeight">
            <summary>
            Keeps the node position relative to the triangle defined by the plane bones (applies only to end-effectors).
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKEffector.PinToBone(System.Single,System.Single)">
            <summary>
            Pins the effector to the animated position of it's bone.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKMapping">
            <summary>
            Maps a bone or a collection of bones to a node based %IK solver
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKMapping.BoneMap">
            <summary>
            Contains mapping information of a single bone
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMapping.BoneMap.transform">
            <summary>
            The transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMapping.BoneMap.chainIndex">
            <summary>
            The node in %IK Solver.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKMapping.BoneMap.swingDirection">
            <summary>
            Gets the current swing direction of the bone in world space.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKMapping.IsValid(RootMotion.FinalIK.IKSolver,System.String@)">
            <summary>
            Determines whether this IKMapping is valid.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKMappingBone">
            <summary>
            Maps a single bone to a node in %IK Solver
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingBone.bone">
            <summary>
            The bone transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingBone.maintainRotationWeight">
            <summary>
            The weight of maintaining the bone's rotation after solver has finished.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKMappingBone.IsValid(RootMotion.FinalIK.IKSolver,System.String@)">
            <summary>
            Determines whether this IKMappingBone is valid.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKMappingLimb">
            <summary>
            Maps a 3-segmented bone hierarchy to a node chain of an %IK Solver
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKMappingLimb.BoneMapType">
            <summary>
            Limb Bone Map type
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingLimb.parentBone">
            <summary>
            The optional parent bone (clavicle).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingLimb.bone1">
            <summary>
            The first bone (upper arm or thigh).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingLimb.bone2">
            <summary>
            The second bone (forearm or calf).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingLimb.bone3">
            <summary>
            The third bone (hand or foot).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingLimb.maintainRotationWeight">
            <summary>
            The weight of maintaining the third bone's rotation as it was in the animation
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingLimb.weight">
            <summary>
            The weight of mapping the limb to it's IK pose. This can be useful if you want to disable the effect of IK for the limb.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKMappingLimb.IsValid(RootMotion.FinalIK.IKSolver,System.String@)">
            <summary>
            Determines whether this IKMappingLimb is valid
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKMappingLimb.GetBoneMap(RootMotion.FinalIK.IKMappingLimb.BoneMapType)">
            <summary>
            Gets the bone map of the specified bone.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKMappingLimb.SetLimbOrientation(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Makes the limb mapped to the specific local directions of the bones. Added in 0.3
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKMappingSpine">
            <summary>
            Mapping a bone hierarchy to 2 triangles defined by the hip and chest planes.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingSpine.spineBones">
            <summary>
            The spine bones.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingSpine.leftUpperArmBone">
            <summary>
            The left upper arm bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingSpine.rightUpperArmBone">
            <summary>
            The right upper arm bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingSpine.leftThighBone">
            <summary>
            The left thigh bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingSpine.rightThighBone">
            <summary>
            The right thigh bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingSpine.iterations">
            <summary>
            The number of iterations of the %FABRIK algorithm. Not used if there are 2 bones assigned to Spine in the References.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKMappingSpine.twistWeight">
            <summary>
            The weight of twisting the spine bones gradually to the orientation of the chest triangle. Relatively expensive, so set this to 0 if there is not much spine twisting going on.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKMappingSpine.IsValid(RootMotion.FinalIK.IKSolver,System.String@)">
            <summary>
            Determines whether this IKMappingSpine is valid
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolver">
            <summary>
            The base abstract class for all %IK solvers
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.IsValid">
            <summary>
            Determines whether this instance is valid or not.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.IsValid(System.String@)">
            <summary>
            Determines whether this instance is valid or not. If returns false, also fills in an error message.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.Initiate(UnityEngine.Transform)">
            <summary>
            Initiate the solver with specified root Transform. Use only if this %IKSolver is not a member of an %IK component.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.Update">
            <summary>
            Updates the %IK solver. Use only if this %IKSolver is not a member of an %IK component or the %IK component has been disabled and you intend to manually control the updating.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.IKPosition">
            <summary>
            The %IK position.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.GetIKPosition">
            <summary>
            Gets the %IK position. NOTE: You are welcome to read IKPosition directly, this method is here only to match the Unity's built in %IK API.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.SetIKPosition(UnityEngine.Vector3)">
            <summary>
            Sets the %IK position. NOTE: You are welcome to set IKPosition directly, this method is here only to match the Unity's built in %IK API.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.GetIKPositionWeight">
            <summary>
            Gets the %IK position weight. NOTE: You are welcome to read IKPositionWeight directly, this method is here only to match the Unity's built in %IK API.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.SetIKPositionWeight(System.Single)">
            <summary>
            Sets the %IK position weight. NOTE: You are welcome to set IKPositionWeight directly, this method is here only to match the Unity's built in %IK API.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.GetRoot">
            <summary>
            Gets the root Transform.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolver.initiated">
            <summary>
            Gets a value indicating whether this <see cref="T:RootMotion.FinalIK.IKSolver"/> has successfully initiated.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.GetPoints">
            <summary>
            Gets all the points used by the solver.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.GetPoint(UnityEngine.Transform)">
            <summary>
            Gets the point with the specified Transform.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.FixTransforms">
            <summary>
            Fixes all the Transforms used by the solver to their initial state.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.StoreDefaultLocalState">
            <summary>
            Stores the default local state for the bones used by the solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolver.Point">
            <summary>
            The most basic element type in the %IK chain that all other types extend from.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Point.transform">
            <summary>
            The transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Point.weight">
            <summary>
            The weight of this bone in the solver.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Point.solverPosition">
            <summary>
            Virtual position in the %IK solver.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Point.solverRotation">
            <summary>
            Virtual rotation in the %IK solver.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Point.defaultLocalPosition">
            <summary>
            The default local position of the Transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Point.defaultLocalRotation">
            <summary>
            The default local rotation of the Transform.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.Point.StoreDefaultLocalState">
            <summary>
            Stores the default local state of the point.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.Point.FixTransform">
            <summary>
            Fixes the transform to it's default local state.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.Point.UpdateSolverPosition">
            <summary>
            Updates the solverPosition (in world space).
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.Point.UpdateSolverLocalPosition">
            <summary>
            Updates the solverPosition (in local space).
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.Point.UpdateSolverState">
            <summary>
            Updates the solverPosition/Rotation (in world space).
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.Point.UpdateSolverLocalState">
            <summary>
            Updates the solverPosition/Rotation (in local space).
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolver.Bone">
            <summary>
            %Bone type of element in the %IK chain. Used in the case of skeletal Transform hierarchies.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Bone.length">
            <summary>
            The length of the bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Bone.sqrMag">
            <summary>
            The sqr mag of the bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Bone.axis">
            <summary>
            Local axis to target/child bone.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolver.Bone.rotationLimit">
            <summary>
            Gets the rotation limit component from the Transform if there is any.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolver.Node">
            <summary>
            %Node type of element in the %IK chain. Used in the case of mixed/non-hierarchical %IK systems
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Node.length">
            <summary>
            Distance to child node.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Node.effectorPositionWeight">
            <summary>
            The effector position weight.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Node.effectorRotationWeight">
            <summary>
            The effector rotation weight.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.Node.offset">
            <summary>
            Position offset.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolver.UpdateDelegate">
            <summary>
            Delegates solver update events.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolver.IterationDelegate">
            <summary>
            Delegates solver iteration events.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.OnPreInitiate">
            <summary>
            Called before initiating the solver.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.OnPostInitiate">
            <summary>
            Called after initiating the solver.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.OnPreUpdate">
            <summary>
            Called before updating.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolver.OnPostUpdate">
            <summary>
            Called after writing the solved pose
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolver.ContainsDuplicateBone(RootMotion.FinalIK.IKSolver.Bone[])">
            <summary>
            Checks if an array of objects contains any duplicates.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverAim">
            <summary>
            Rotates a hierarchy of bones to make a Transform aim at a target.
            If there are problems with continuity and the solver get's jumpy, make sure to keep IKPosition at a safe distance from the transform and try decreasing solver and bone weights.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverAim.transform">
            <summary>
            The transform that we want to aim at IKPosition.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverAim.axis">
            <summary>
            The local axis of the Transform that you want to be aimed at IKPosition.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverAim.poleAxis">
            <summary>
            Keeps that axis of the Aim Transform directed at the polePosition.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverAim.polePosition">
            <summary>
            The position in world space to keep the pole axis of the Aim Transform directed at.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverAim.poleWeight">
            <summary>
            The weight of the Pole.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverAim.poleTarget">
            <summary>
            If assigned, will automatically set polePosition to the position of this Transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverAim.clampWeight">
            <summary>
            Clamping rotation of the solver. 0 is free rotation, 1 is completely clamped to transform axis.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverAim.clampSmoothing">
            <summary>
            Number of sine smoothing iterations applied to clamping to make it smoother.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverAim.GetAngle">
            <summary>
            Gets the angular offset.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverAim.transformAxis">
            <summary>
            Gets the Axis of the AimTransform is world space.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverAim.transformPoleAxis">
            <summary>
            Gets the Pole Axis of the AimTransform is world space.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverAim.OnPreIteration">
            <summary>
            Called before each iteration of the solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverCCD">
            <summary>
            CCD (Cyclic Coordinate Descent) constrainable heuristic inverse kinematics algorithm.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverCCD.FadeOutBoneWeights">
            <summary>
            CCD tends to overemphasise the rotations of the bones closer to the target position. Reducing bone weight down the hierarchy will compensate for this effect.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverCCD.OnPreIteration">
            <summary>
            Called before each iteration of the solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverFABRIK">
            <summary>
            Forward and Backward Reaching Inverse Kinematics solver.
            
            This class is based on the "FABRIK: A fast, iterative solver for the inverse kinematics problem." paper by Aristidou, A., Lasenby, J.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFABRIK.SolveForward(UnityEngine.Vector3)">
            <summary>
            Solving stage 1 of the %FABRIK algorithm.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFABRIK.SolveBackward(UnityEngine.Vector3)">
            <summary>
            Solving stage 2 of the %FABRIK algorithm.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFABRIK.OnPreIteration">
            <summary>
            Called before each iteration of the solver.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverFABRIKRoot">
            <summary>
            %IK system for multiple branched %FABRIK chains.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFABRIKRoot.iterations">
            <summary>
            Solver iterations.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFABRIKRoot.rootPin">
            <summary>
            The weight of all chains being pinned to root position.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFABRIKRoot.chains">
            <summary>
            The %FABRIK chains.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverFullBody">
            <summary>
            Generic FBIK solver. In each solver update, %IKSolverFullBody first reads the character's pose, then solves the %IK and writes the solved pose back to the character via IKMapping.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.iterations">
            <summary>
            Number of solver iterations.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.chain">
            <summary>
            The root node chain.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.effectors">
            <summary>
            The effectors.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.spineMapping">
            <summary>
            Mapping spine bones to the solver.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.boneMappings">
            <summary>
            Mapping individual bones to the solver
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.limbMappings">
            <summary>
            Mapping 3 segment limbs to the solver
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.FABRIKPass">
            <summary>
            If false, will not solve a FABRIK pass and the arms/legs will not be able to pull the body.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBody.GetEffector(UnityEngine.Transform)">
            <summary>
            Gets the effector of the specified Transform.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBody.GetChain(UnityEngine.Transform)">
            <summary>
            Gets the chain that contains the specified Transform.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBody.GetChainIndex(UnityEngine.Transform)">
            <summary>
            Gets the index of the chain (in the IKSolverFullBody.chain array) that contains the specified Transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.OnPreRead">
            <summary>
            Called before reading the pose
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.OnPreSolve">
            <summary>
            Called before solving.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.OnPreIteration">
            <summary>
            Called before each iteration
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.OnPostIteration">
            <summary>
            Called after each iteration
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.OnPreBend">
            <summary>
            Called before applying bend constraints.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.OnPostSolve">
            <summary>
            Called after updating the solver
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.OnStoreDefaultLocalState">
            <summary>
            Called when storing default local state (the state that FixTransforms will reset the hierarchy to).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBody.OnFixTransforms">
            <summary>
            Called when the bones used by the solver will reset to the default local state.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FullBodyBipedEffector">
            <summary>
            Full body biped IK effector types.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.FullBodyBipedChain">
            <summary>
            Full body biped IK chain types.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverFullBodyBiped">
            <summary>
            FBIK solver specialized to biped characters.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBodyBiped.rootNode">
            <summary>
            The central root node (body).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBodyBiped.spineStiffness">
            <summary>
            The stiffness of spine constraints.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBodyBiped.pullBodyVertical">
            <summary>
            Weight of hand effectors pulling the body vertically (relative to root rotation).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverFullBodyBiped.pullBodyHorizontal">
            <summary>
            Weight of hand effectors pulling the body horizontally (relative to root rotation).
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.bodyEffector">
            <summary>
            Gets the body effector.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.leftShoulderEffector">
            <summary>
            Gets the left shoulder effector.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.rightShoulderEffector">
            <summary>
            Gets the right shoulder effector.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.leftThighEffector">
            <summary>
            Gets the left thigh effector.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.rightThighEffector">
            <summary>
            Gets the right thigh effector.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.leftHandEffector">
            <summary>
            Gets the left hand effector.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.rightHandEffector">
            <summary>
            Gets the right hand effector.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.leftFootEffector">
            <summary>
            Gets the left foot effector.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.rightFootEffector">
            <summary>
            Gets the right foot effector.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.leftArmChain">
            <summary>
            Gets the left arm chain.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.rightArmChain">
            <summary>
            Gets the right arm chain.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.leftLegChain">
            <summary>
            Gets the left leg chain.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.rightLegChain">
            <summary>
            Gets the right leg chain.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.leftArmMapping">
            <summary>
            Gets the left arm IK mapping.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.rightArmMapping">
            <summary>
            Gets the right arm IK mapping.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.leftLegMapping">
            <summary>
            Gets the left leg IK mapping.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.rightLegMapping">
            <summary>
            Gets the right leg IK mapping.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverFullBodyBiped.headMapping">
            <summary>
            Gets the head IK mapping.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.SetChainWeights(RootMotion.FinalIK.FullBodyBipedChain,System.Single,System.Single)">
            <summary>
            Sets chain weights for the specified chain.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.SetEffectorWeights(RootMotion.FinalIK.FullBodyBipedEffector,System.Single,System.Single)">
            <summary>
            Sets effector weights for the specified effector.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.GetChain(RootMotion.FinalIK.FullBodyBipedChain)">
            <summary>
             Gets the chain of a limb.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.GetChain(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
             Gets the chain of the specified effector. 
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.GetEffector(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
             Gets the effector of type. 
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.GetEndEffector(RootMotion.FinalIK.FullBodyBipedChain)">
            <summary>
             Gets the effector of type. 
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.GetLimbMapping(RootMotion.FinalIK.FullBodyBipedChain)">
            <summary>
            Gets the limb mapping for the limb.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.GetLimbMapping(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
            Gets the limb mapping for the effector type.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.GetSpineMapping">
            <summary>
            Gets the spine mapping.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.GetHeadMapping">
            <summary>
            Gets the head mapping.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.GetBendConstraint(RootMotion.FinalIK.FullBodyBipedChain)">
            <summary>
            Gets the bend constraint of a limb.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.SetToReferences(RootMotion.BipedReferences,UnityEngine.Transform)">
            <summary>
            Sets up the solver to BipedReferences and reinitiates (if in runtime).
            </summary>
            <param name="references">Biped references.</param>
            <param name="rootNode">Root node (optional). if null, will try to detect the root node bone automatically. </param>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverFullBodyBiped.SetLimbOrientations(RootMotion.BipedLimbOrientations)">
            <summary>
            Sets the bend directions of the limbs to the local axes specified by BipedLimbOrientations.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverHeuristic">
            <summary>
            Contains methods common for all heuristic solvers.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverHeuristic.target">
            <summary>
            The target Transform. Solver IKPosition will be automatically set to the position of the target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverHeuristic.tolerance">
            <summary>
            Minimum distance from last reached position. Will stop solving if difference from previous reached position is less than tolerance. If tolerance is zero, will iterate until maxIterations.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverHeuristic.maxIterations">
            <summary>
            Max iterations per frame
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverHeuristic.useRotationLimits">
            <summary>
            If true, rotation limits (if excisting) will be applied on each iteration.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverHeuristic.XY">
            <summary>
            Solve in 2D?
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverHeuristic.bones">
            <summary>
            The hierarchy of bones.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverHeuristic.SetChain(UnityEngine.Transform[],UnityEngine.Transform)">
            <summary>
            Rebuild the bone hierarcy and reinitiate the solver.
            </summary>
            <returns>
            Returns true if the new chain is valid.
            </returns>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverHeuristic.AddBone(UnityEngine.Transform)">
            <summary>
            Adds a bone to the chain.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverLeg">
            <summary>
            A wrapper for making IKSolverVRLeg work with other IK components and the Grounder.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLeg.IKRotation">
            <summary>
            The %IK rotation target.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLeg.SetChain(UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Reinitiate the solver with new bone Transforms.
            </summary>
            <returns>
            Returns true if the new chain is valid.
            </returns>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverLimb">
            <summary>
            Extends IKSolverTrigonometric to add automatic bend and rotation modes.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLimb.goal">
            <summary>
            The AvatarIKGoal of this solver.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLimb.bendModifier">
            <summary>
            Bend normal modifier.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLimb.maintainRotationWeight">
            <summary>
            Weight of maintaining the rotation of the third bone as it was before solving.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLimb.bendModifierWeight">
            <summary>
            Weight of bend normal modifier.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLimb.bendGoal">
            <summary>
            The bend goal Transform.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLimb.MaintainRotation">
            <summary>
            Used to record rotation of the last bone for one frame. 
            If MaintainRotation is not called and maintainRotationWeight > 0, the solver will maintain the rotation of the last bone as it was before solving the %IK.
            You will probably need this if you wanted to maintain the animated rotation of a foot despite of any other %IK solver that manipulates it's parents' rotation.
            So you would call %MaintainRotation() in LateUpdate() after animation and before updating the Spine %IK solver that would change the foot's rotation.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLimb.MaintainBend">
            <summary>
            If Auto Bend is on "Animation', %MaintainBend() can be used to set the bend axis relative to the first bone's rotation.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverLimb.BendModifier">
            <summary>
            Automatic bend modes.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverLookAt">
            <summary>
            Rotates a hierarchy of bones to face a target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.target">
            <summary>
            The target Transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.spine">
            <summary>
            The spine hierarchy.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.head">
            <summary>
            The head bone.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.eyes">
            <summary>
            The eye bones.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.bodyWeight">
            <summary>
            The body weight.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.headWeight">
            <summary>
            The head weight.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.eyesWeight">
            <summary>
            The eyes weight.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.clampWeight">
            <summary>
            Clamp weight for the body.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.clampWeightHead">
            <summary>
            Clamp weight for the head.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.clampWeightEyes">
            <summary>
            Clamp weight for the eyes.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.clampSmoothing">
            <summary>
            Number of sine smoothing iterations applied on clamping to make the clamping point smoother.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.spineWeightCurve">
            <summary>
            Weight distribution between the spine bones.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverLookAt.spineTargetOffset">
            <summary>
            Offset for the spine target in world space..
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLookAt.SetLookAtWeight(System.Single)">
            <summary>
            Sets the look at weight. NOTE: You are welcome edit the weights directly, this method is here only to match the Unity's built in %IK API.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLookAt.SetLookAtWeight(System.Single,System.Single)">
            <summary>
            Sets the look at weight. NOTE: You are welcome to edit the weights directly, this method is here only to match the Unity's built in %IK API.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLookAt.SetLookAtWeight(System.Single,System.Single,System.Single)">
            <summary>
            Sets the look at weight. NOTE: You are welcome to edit the weights directly, this method is here only to match the Unity's built in %IK API.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLookAt.SetLookAtWeight(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the look at weight. NOTE: You are welcome to edit the weights directly, this method is here only to match the Unity's built in %IK API.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLookAt.SetLookAtWeight(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the look at weight. NOTE: You are welcome to edit the weights directly, this method is here only to match the Unity's built in %IK API. 
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLookAt.SetLookAtWeight(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the look at weight. NOTE: You are welcome to edit the weights directly, this method is here only to match the Unity's built in %IK API.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverLookAt.LookAtBone">
            <summary>
            Look At bone class.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverLookAt.SetChain(UnityEngine.Transform[],UnityEngine.Transform,UnityEngine.Transform[],UnityEngine.Transform)">
            <summary>
            Reinitiate the solver with new bone Transforms.
            </summary>
            <returns>
            Returns true if the new chain is valid.
            </returns>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverTrigonometric">
            <summary>
            Analytic %IK solver based on the Law of Cosines.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverTrigonometric.target">
            <summary>
            The target Transform.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverTrigonometric.IKRotationWeight">
            <summary>
            The %IK rotation weight (rotation of the last bone).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverTrigonometric.IKRotation">
            <summary>
            The %IK rotation target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverTrigonometric.bendNormal">
            <summary>
            The bend plane normal.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverTrigonometric.bone1">
            <summary>
            The first bone (upper arm or thigh).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverTrigonometric.bone2">
            <summary>
            The second bone (forearm or calf).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverTrigonometric.bone3">
            <summary>
            The third bone (hand or foot).
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverTrigonometric.SetBendGoalPosition(UnityEngine.Vector3,System.Single)">
            <summary>
            Sets the bend goal position.
            </summary>
            <param name='goalPosition'>
            Goal position.
            </param>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverTrigonometric.SetBendPlaneToCurrent">
            <summary>
            Sets the bend plane to match current bone rotations.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverTrigonometric.SetIKRotation(UnityEngine.Quaternion)">
            <summary>
            Sets the %IK rotation.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverTrigonometric.SetIKRotationWeight(System.Single)">
            <summary>
            Sets the %IK rotation weight.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverTrigonometric.GetIKRotation">
            <summary>
            Gets the %IK rotation.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverTrigonometric.GetIKRotationWeight">
            <summary>
            Gets the %IK rotation weight.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverTrigonometric.TrigonometricBone">
            <summary>
            Bone type used by IKSolverTrigonometric.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverTrigonometric.SetChain(UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Reinitiate the solver with new bone Transforms.
            </summary>
            <returns>
            Returns true if the new chain is valid.
            </returns>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverTrigonometric.Solve(UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Solve the bone chain.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverVR">
            <summary>
            Hybrid %IK solver designed for mapping a character to a VR headset and 2 hand controllers 
            </summary>
            <summary>
            Hybrid %IK solver designed for mapping a character to a VR headset and 2 hand controllers 
            </summary>
            <summary>
            Hybrid %IK solver designed for mapping a character to a VR headset and 2 hand controllers 
            </summary>
            <summary>
            Hybrid %IK solver designed for mapping a character to a VR headset and 2 hand controllers 
            </summary>
            <summary>
            Hybrid %IK solver designed for mapping a character to a VR headset and 2 hand controllers 
            </summary>
            <summary>
            Hybrid %IK solver designed for mapping a character to a VR headset and 2 hand controllers 
            </summary>
            <summary>
            Hybrid %IK solver designed for mapping a character to a VR headset and 2 hand controllers 
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverVR.SetToReferences(RootMotion.FinalIK.VRIK.References)">
            <summary>
            Sets this VRIK up to the specified bone references.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverVR.GuessHandOrientations(RootMotion.FinalIK.VRIK.References,System.Boolean)">
            <summary>
            Guesses the hand bones orientations ('Wrist To Palm Axis' and "Palm To Thumb Axis" of the arms) based on the provided references. if onlyIfZero is true, will only guess an orientation axis if it is Vector3.zero.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverVR.DefaultAnimationCurves">
            <summary>
            Set default values for the animation curves if they have no keys.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverVR.AddPositionOffset(RootMotion.FinalIK.IKSolverVR.PositionOffset,UnityEngine.Vector3)">
            <summary>
            Adds position offset to a body part. Position offsets add to the targets in VRIK.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverVR.AddRotationOffset(RootMotion.FinalIK.IKSolverVR.RotationOffset,UnityEngine.Vector3)">
            <summary>
            Adds rotation offset to a body part. Rotation offsets add to the targets in VRIK
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverVR.AddRotationOffset(RootMotion.FinalIK.IKSolverVR.RotationOffset,UnityEngine.Quaternion)">
            <summary>
            Adds rotation offset to a body part. Rotation offsets add to the targets in VRIK
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverVR.AddPlatformMotion(UnityEngine.Vector3,UnityEngine.Quaternion,UnityEngine.Vector3)">
            <summary>
            Call this in each Update if your avatar is standing on a moving platform
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverVR.Reset">
            <summary>
            Resets all tweens, blendings and lerps. Call this after you have teleported the character.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverVR.rootBone">
            <summary>
            Gets the root bone.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverVR.Arm">
            <summary>
            4-segmented analytic arm chain.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Arm.IKPosition">
            <summary>
            Target position of the hand. Will be overwritten if target is assigned.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Arm.IKRotation">
            <summary>
            Target rotation of the hand. Will be overwritten if target is assigned.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Arm.bendDirection">
            <summary>
            The bending direction of the limb. Will be used if bendGoalWeight is greater than 0. Will be overwritten if bendGoal is assigned.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Arm.handPositionOffset">
            <summary>
            Position offset of the hand. Will be applied on top of hand target position and reset to Vector3.zero after each update.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverVR.BodyPart">
            <summary>
            A base class for limbs of all types.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverVR.Leg">
            <summary>
            4-segmented analytic leg chain.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Leg.IKPosition">
            <summary>
            Target position of the toe/foot. Will be overwritten if target is assigned.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Leg.IKRotation">
            <summary>
            Target rotation of the toe/foot. Will be overwritten if target is assigned.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Leg.footPositionOffset">
            <summary>
            Position offset of the toe/foot. Will be applied on top of target position and reset to Vector3.zero after each update.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Leg.heelPositionOffset">
            <summary>
            Position offset of the heel. Will be reset to Vector3.zero after each update.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Leg.footRotationOffset">
            <summary>
            Rotation offset of the toe/foot. Will be reset to Quaternion.identity after each update.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Leg.currentMag">
            <summary>
            The length of the leg (calculated in last read).
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.IKSolverVR.Locomotion.centerOfMass">
            <summary>
            Gets the approximated center of mass.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.IKSolverVR.Spine">
            <summary>
            Spine solver for IKSolverVR.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.IKPositionHead">
            <summary>
            Target position of the head. Will be overwritten if target is assigned.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.IKRotationHead">
            <summary>
            Target rotation of the head. Will be overwritten if target is assigned.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.IKPositionPelvis">
            <summary>
            Target position of the pelvis. Will be overwritten if target is assigned.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.IKRotationPelvis">
            <summary>
            Target rotation of the pelvis. Will be overwritten if target is assigned.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.goalPositionChest">
            <summary>
            The goal position for the chest. If chestGoalWeight > 0, the chest will be turned towards this position.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.pelvisPositionOffset">
            <summary>
            Position offset of the pelvis. Will be applied on top of pelvis target position and reset to Vector3.zero after each update.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.chestPositionOffset">
            <summary>
            Position offset of the chest. Will be reset to Vector3.zero after each update.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.headPositionOffset">
            <summary>
            Position offset of the head. Will be applied on top of head target position and reset to Vector3.zero after each update.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.pelvisRotationOffset">
            <summary>
            Rotation offset of the pelvis. Will be reset to Quaternion.identity after each update.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.chestRotationOffset">
            <summary>
            Rotation offset of the chest. Will be reset to Quaternion.identity after each update.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.IKSolverVR.Spine.headRotationOffset">
            <summary>
            Rotation offset of the head. Will be applied on top of head target rotation and reset to Quaternion.identity after each update.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.IKSolverVR.VirtualBone.SolveTrigonometric(RootMotion.FinalIK.IKSolverVR.VirtualBone[],System.Int32,System.Int32,System.Int32,UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Solve the bone chain virtually using both solverPositions and SolverRotations. This will work the same as IKSolverTrigonometric.Solve.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.TwistRelaxer">
            <summary>
            Relaxes the twist rotation of this Transform relative to a parent and a child Transform, using their initial rotations as the most relaxed pose.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.TwistRelaxer.Relax">
            <summary>
            Rotate this Transform to relax it's twist angle relative to the "parent" and "child" Transforms.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionEffector">
            <summary>
            Managing Interactions for a single FBBIK effector.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionLookAt">
            <summary>
            Controls LookAtIK for the InteractionSystem
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionLookAt.lerpSpeed">
            <summary>
            Interpolation speed of the LookAtIK target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionLookAt.weightSpeed">
            <summary>
            Interpolation speed of the LookAtIK weight.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionLookAt.Look(UnityEngine.Transform,System.Single)">
            <summary>
            Look the specified target for the specified time.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionObject">
            <summary>
            Object than the InteractionSystem can interact with.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionObject.InteractionEvent">
            <summary>
            Predefined interaction events for pausing, picking up, triggering animations and sending messages.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.InteractionEvent.time">
            <summary>
            The time of the event since interaction start.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.InteractionEvent.pause">
            <summary>
            If true, the interaction will be paused on this event. The interaction can be resumed by InteractionSystem.ResumeInteraction() or InteractionSystem.ResumeAll;
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.InteractionEvent.pickUp">
            <summary>
            If true, the object will be parented to the effector bone on this event. Note that picking up like this can be done by only a single effector at a time.
            If you wish to pick up an object with both hands, see the Interaction PickUp2Handed demo scene.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.InteractionEvent.animations">
            <summary>
            The animations called on this event.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.InteractionEvent.messages">
            <summary>
            The messages sent on this event using GameObject.SendMessage().
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionObject.Message">
            <summary>
            Definition of a message sent by an InteractionEvent.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.Message.function">
            <summary>
            The name of the function called.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.Message.recipient">
            <summary>
            The recipient game object.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionObject.AnimatorEvent">
            <summary>
            Calls an animation on an interaction event.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.AnimatorEvent.animator">
            <summary>
            The Animator component that will receive the AnimatorEvents.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.AnimatorEvent.animation">
            <summary>
            The Animation component that will receive the AnimatorEvents (Legacy).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.AnimatorEvent.animationState">
            <summary>
            The name of the animation state.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.AnimatorEvent.crossfadeTime">
            <summary>
            The crossfading time.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.AnimatorEvent.layer">
            <summary>
            The layer of the animation state (if using Legacy, the animation state will be forced to this layer).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.AnimatorEvent.resetNormalizedTime">
            <summary>
            Should the animation always start from 0 normalized time?
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionObject.WeightCurve">
            <summary>
            A Weight curve for various FBBIK channels.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionObject.WeightCurve.Type">
            <summary>
            The type of the weight curve
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.WeightCurve.type">
            <summary>
            The type of the curve (InteractionObject.WeightCurve.Type).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.WeightCurve.curve">
            <summary>
            The weight curve.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionObject.Multiplier">
            <summary>
            Multiplies a weight curve and uses the result for another FBBIK channel. (to reduce the amount of work with AnimationCurves)
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.Multiplier.curve">
            <summary>
            The curve type to multiply.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.Multiplier.multiplier">
            <summary>
            The multiplier of the curve's value.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.Multiplier.result">
            <summary>
            The resulting value will be applied to this channel.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.otherLookAtTarget">
            <summary>
            If the Interaction System has a 'Look At' LookAtIK component assigned, will use it to make the character look at the specified Transform. If unassigned, will look at this GameObject.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:RootMotion.FinalIK.InteractionObject.otherTargetsRoot" -->
        <member name="F:RootMotion.FinalIK.InteractionObject.positionOffsetSpace">
            <summary>
            If assigned, all PositionOffset channels will be applied in the rotation space of this Transform. If not, they will be in the rotation space of the character.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.weightCurves">
            <summary>
            The weight curves for the interaction.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.multipliers">
            <summary>
            The weight curve multipliers for the interaction.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionObject.events">
            <summary>
            The interaction events.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.InteractionObject.length">
            <summary>
            Gets the length of the interaction (the longest curve).
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.InteractionObject.lastUsedInteractionSystem">
            <summary>
            The last InteractionSystem that started an interaction with this InteractionObject.
            </summary>
            <value>The last used interaction system.</value>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionObject.Initiate">
            <summary>
            Call if you have changed the curves in play mode or added/removed InteractionTargets.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.InteractionObject.lookAtTarget">
            <summary>
            Gets the look at target (returns otherLookAtTarget if not null).
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionObject.GetTarget(RootMotion.FinalIK.FullBodyBipedEffector,RootMotion.FinalIK.InteractionSystem)">
            <summary>
            Gets the InteractionTarget of the specified effector type and InteractionSystem tag.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionSystem">
            <summary>
            Handles FBBIK interactions for a character.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.targetTag">
            <summary>
            If not empty, only the targets with the specified tag will be used by this Interaction System.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.fadeInTime">
            <summary>
            The fade in time of the interaction.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.speed">
            <summary>
            The master speed for all interactions.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.resetToDefaultsSpeed">
            <summary>
            If > 0, lerps all the FBBIK channels used by the Interaction System back to their default or initial values when not in interaction.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.FPSCamera">
            <summary>
            Will be used by Interaction Triggers that need the camera's position. Assign the first person view character camera.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.camRaycastLayers">
            <summary>
            The layers that will be raycasted from the camera (along camera.forward). All InteractionTrigger look at target colliders should be included.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.camRaycastDistance">
            <summary>
            Max distance of raycasting from the camera.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.InteractionSystem.inInteraction">
            <summary>
            Returns true if any of the effectors is in interaction and not paused.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.IsInInteraction(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
            Determines whether this effector is interaction and not paused
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.IsPaused(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
            Determines whether this effector is  paused
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.IsPaused">
            <summary>
            Returns true if any of the effectors is paused
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.IsInSync">
            <summary>
            Returns true if either all effectors in interaction are paused or none is.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.StartInteraction(RootMotion.FinalIK.FullBodyBipedEffector,RootMotion.FinalIK.InteractionObject,System.Boolean)">
            <summary>
            Starts the interaction between an effector and an interaction object.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.PauseInteraction(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
            Pauses the interaction of an effector.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.ResumeInteraction(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
            Resumes the paused interaction of an effector.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.StopInteraction(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
            Stops the interaction of an effector.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.PauseAll">
            <summary>
            Pauses all the interaction effectors.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.ResumeAll">
            <summary>
            Resumes all the paused interaction effectors.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.StopAll">
            <summary>
            Stops all interactions.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetInteractionObject(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
            Gets the current interaction object of an effector.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetProgress(RootMotion.FinalIK.FullBodyBipedEffector)">
            <summary>
            Gets the progress of any interaction with the specified effector.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetMinActiveProgress">
            <summary>
            Gets the minimum progress of any active interaction
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.TriggerInteraction(System.Int32,System.Boolean)">
            <summary>
            Triggers all interactions of an InteractionTrigger. Returns false if unsuccessful (maybe out of range).
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.TriggerInteraction(System.Int32,System.Boolean,RootMotion.FinalIK.InteractionObject@)">
            <summary>
            Triggers all interactions of an InteractionTrigger. Returns false if unsuccessful (maybe out of range).
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.TriggerInteraction(System.Int32,System.Boolean,RootMotion.FinalIK.InteractionTarget@)">
            <summary>
            Triggers all interactions of an InteractionTrigger. Returns false if unsuccessful (maybe out of range).
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetClosestInteractionRange">
            <summary>
            Gets the closest InteractionTrigger Range.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetClosestInteractionObjectInRange">
            <summary>
            Gets the closest InteractionObject in range.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetClosestInteractionTargetInRange">
            <summary>
            Gets the closest InteractionTarget in range.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetClosestInteractionObjectsInRange">
            <summary>
            Gets the closest InteractionObjects in range.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetClosestInteractionTargetsInRange">
            <summary>
            Gets the closest InteractionTargets in range.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.TriggerEffectorsReady(System.Int32)">
            <summary>
            Returns true if all effectors of a trigger are either not in interaction or paused
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetTriggerRange(System.Int32)">
            <summary>
            Return the current most appropriate range of an InteractionTrigger listed in triggersInRange.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.InteractionSystem.GetClosestTriggerIndex">
            <summary>
            Returns the InteractionTrigger that is in range and closest to the character.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.InteractionSystem.ik">
            <summary>
            Gets the FullBodyBipedIK component.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.InteractionSystem.triggersInRange">
            <summary>
            Gets the in contact.
            </summary>
            <value>The in contact.</value>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionSystem.InteractionDelegate">
            <summary>
            Interaction delegate
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionSystem.InteractionEventDelegate">
            <summary>
            Interaction event delegate
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.OnInteractionStart">
            <summary>
            Called when an InteractionEvent has been started
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.OnInteractionPause">
            <summary>
            Called when an Interaction has been paused
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.OnInteractionPickUp">
            <summary>
            Called when an InteractionObject has been picked up.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.OnInteractionResume">
            <summary>
            Called when a paused Interaction has been resumed
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.OnInteractionStop">
            <summary>
            Called when an Interaction has been stopped
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.OnInteractionEvent">
            <summary>
            Called when an interaction event occurs.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.raycastHit">
            <summary>
            Gets the RaycastHit from trigger seeking.
            </summary>
            <value>The hit.</value>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionSystem.lookAt">
            <summary>
            Handles looking at the interactions.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionTarget">
            <summary>
            The target of an effector in the InteractionSystem.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionTarget.Multiplier">
            <summary>
            Multiplies the value of a weight curve for this effector target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.Multiplier.curve">
            <summary>
            The curve type (InteractionObject.WeightCurve.Type).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.Multiplier.multiplier">
            <summary>
            Multiplier of the curve's value.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.effectorType">
            <summary>
            The type of the FBBIK effector.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.multipliers">
            <summary>
            InteractionObject weight curve multipliers for this effector target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.interactionSpeedMlp">
            <summary>
            The interaction speed multiplier for this effector. This can be used to make interactions faster/slower for specific effectors.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.pivot">
            <summary>
            The pivot to twist/swing this interaction target about. For symmetric objects that can be interacted with from a certain angular range.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.twistAxis">
            <summary>
            The axis of twisting the interaction target.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.twistWeight">
            <summary>
            The weight of twisting the interaction target towards the effector bone in the start of the interaction.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.swingWeight">
            <summary>
            The weight of swinging the interaction target towards the effector bone in the start of the interaction. Swing is defined as a 3-DOF rotation around any axis, while twist is only around the twist axis.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTarget.rotateOnce">
            <summary>
            If true, will twist/swing around the pivot only once at the start of the interaction. If false, will continue rotating throuout the whole interaction.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionTrigger">
            <summary>
            When a character with an InteractionSystem component enters the trigger collider of this game object, this component will register itself to the InteractionSystem. 
            The InteractionSystem can then use it to find the most appropriate InteractionObject and effectors to interact with.
            Use InteractionSystem.GetClosestTriggerIndex() and InteractionSystem.TriggerInteration() to trigger the interactions that the character is in contact with.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionTrigger.CharacterPosition">
            <summary>
            Defines the valid range of the character's position and rotation relative to this trigger.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CharacterPosition.use">
            <summary>
            If false, will not care where the character stands, as long as it is in contact with the trigger collider.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CharacterPosition.offset">
            <summary>
            The offset of the character's position relative to the trigger in XZ plane. Y position of the character is unlimited as long as it is contact with the collider.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CharacterPosition.angleOffset">
            <summary>
            Angle offset from the default forward direction..
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CharacterPosition.maxAngle">
            <summary>
            Max angular offset of the character's forward from the direction of this trigger.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CharacterPosition.radius">
            <summary>
            Max offset of the character's position from this range's center.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CharacterPosition.orbit">
            <summary>
            If true, will rotate the trigger around it's Y axis relative to the position of the character, so the object can be interacted with from all sides.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CharacterPosition.fixYAxis">
            <summary>
            Fixes the Y axis of the trigger to Vector3.up. This makes the trigger symmetrical relative to the object.
            For example a gun will be able to be picked up from the same direction relative to the barrel no matter which side the gun is resting on. 
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionTrigger.CameraPosition">
            <summary>
            Defines the valid range of the camera's position relative to this trigger.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CameraPosition.lookAtTarget">
            <summary>
            What the camera should be looking at to trigger the interaction?
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CameraPosition.direction">
            <summary>
            The direction from the lookAtTarget towards the camera (in lookAtTarget's space).
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CameraPosition.maxDistance">
            <summary>
            Max distance from the lookAtTarget to the camera.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CameraPosition.maxAngle">
            <summary>
            Max angle between the direction and the direction towards the camera.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.CameraPosition.fixYAxis">
            <summary>
            Fixes the Y axis of the trigger to Vector3.up. This makes the trigger symmetrical relative to the object.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionTrigger.Range">
            <summary>
            Defines the valid range of the character's and/or it's camera's position for one or multiple interactions.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.InteractionTrigger.Range.Interaction">
            <summary>
            Defines the interaction object and effectors that will be triggered when calling InteractionSystem.TriggerInteraction().
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.Range.Interaction.interactionObject">
            <summary>
            The InteractionObject to interact with.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.Range.Interaction.effectors">
            <summary>
            The effectors to interact with.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.Range.characterPosition">
            <summary>
            The range for the character's position and rotation.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.Range.cameraPosition">
            <summary>
            The range for the character camera's position and rotation.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.Range.interactions">
            <summary>
            Definitions of the interactions associated with this range.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.InteractionTrigger.ranges">
            <summary>
            The valid ranges of the character's and/or it's camera's position for triggering interaction when the character is in contact with the collider of this trigger.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.GenericPoser">
            <summary>
            Posing the children of a Transform to match the children of another Transform
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.GenericPoser.Map">
            <summary>
            Mapping a bone to it's target
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.GenericPoser.AutoMapping">
            <summary>
            Finds mapping automatically. This requires for all children of the transform to have unique names. This method is not very memory efficient so try to avoid using it in play mode.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HandPoser">
            <summary>
            Posing the children of a Transform to match the children of another Transform
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Poser">
            <summary>
            The base abstract class for all class that are translating a hierarchy of bones to match the translation of bones in another hierarchy.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Poser.poseRoot">
            <summary>
            Reference to the other Transform (should be identical to this one)
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Poser.weight">
            <summary>
            The master weight.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Poser.localRotationWeight">
            <summary>
            Weight of localRotation matching
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.Poser.localPositionWeight">
            <summary>
            Weight of localPosition matching
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Poser.AutoMapping">
            <summary>
            Map this instance to the poseRoot.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.RagdollUtility">
            <summary>
            Ragdoll Utility controls switching characters in and out of ragdoll mode. It also enables you to use IK effects on top of ragdoll simulation.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.RagdollUtility.EnableRagdoll">
            <summary>
            Switches to ragdoll.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.RagdollUtility.DisableRagdoll">
            <summary>
            Blends back to animation.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.RotationLimit">
            <summary>
            The base abstract class for all Rotation limits. Contains common functionality and static helper methods
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.RotationLimit.axis">
            <summary>
            The main axis of the rotation limit.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.RotationLimit.SetDefaultLocalRotation">
            <summary>
            Map the zero rotation point to the current rotation
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.RotationLimit.GetLimitedLocalRotation(UnityEngine.Quaternion,System.Boolean@)">
            <summary>
            Returns the limited local rotation.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.RotationLimit.Apply">
            <summary>
            Apply the rotation limit to transform.localRotation. Returns true if the limit has changed the rotation.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.RotationLimit.Disable">
            <summary>
            Disable this instance making sure it is initiated. Use this if you intend to manually control the updating of this Rotation Limit.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.RotationLimitAngle">
            <summary>
            Simple angular rotation limit.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.RotationLimitAngle.limit">
            <summary>
            The swing limit.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.RotationLimitAngle.twistLimit">
            <summary>
            Limit of twist rotation around the main axis.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.RotationLimitHinge">
            <summary>
            The hinge rotation limit limits the rotation to 1 degree of freedom around Axis. This rotation limit is additive which means the limits can exceed 360 degrees.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.RotationLimitHinge.useLimits">
            <summary>
            Should the rotation be limited around the axis?
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.RotationLimitHinge.min">
            <summary>
            The min limit around the axis.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.RotationLimitHinge.max">
            <summary>
            The max limit around the axis.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.RotationLimitPolygonal">
            <summary>
            Using a spherical polygon to limit the range of rotation on universal and ball-and-socket joints. A reach cone is specified as a spherical polygon 
            on the surface of a a reach sphere that defines all positions the longitudinal segment axis beyond the joint can take.
            
            This class is based on the "Fast and Easy Reach-Cone Joint Limits" paper by Jane Wilhelms and Allen Van Gelder. 
            Computer Science Dept., University of California, Santa Cruz, CA 95064. August 2, 2001
            http://users.soe.ucsc.edu/~avg/Papers/jtl.pdf
            
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.RotationLimitPolygonal.twistLimit">
            <summary>
            Limit of twist rotation around the main axis.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.RotationLimitPolygonal.smoothIterations">
            <summary>
            The number of smoothing iterations applied to the polygon.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.RotationLimitPolygonal.SetLimitPoints(RootMotion.FinalIK.RotationLimitPolygonal.LimitPoint[])">
            <summary>
            Sets the limit points and recalculates the reach cones.
            </summary>
            <param name='_points'>
            _points.
            </param>
        </member>
        <member name="T:RootMotion.FinalIK.RotationLimitSpline">
            <summary>
            Using a spline to limit the range of rotation on universal and ball-and-socket joints. 
            Reachable area is defined by an AnimationCurve orthogonally mapped onto a sphere.
            </summary>
        </member>
        <member name="F:RootMotion.FinalIK.RotationLimitSpline.twistLimit">
            <summary>
            Limit of twist rotation around the main axis.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.RotationLimitSpline.SetSpline(UnityEngine.Keyframe[])">
            <summary>
            Set the spline keyframes.
            </summary>
            <param name='keyframes'>
            Keyframes.
            </param>
        </member>
        <member name="T:RootMotion.FinalIK.AimController">
            <summary>
            Handles smooth aim target switching, weight blending, target interpolation and root rotation.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.AimPoser">
            <summary>
            Aim Poser returns a reference by direction.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.AimPoser.Pose">
            <summary>
            the pose definition
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.AimPoser.GetPose(UnityEngine.Vector3)">
            <summary>
            Gets the pose by direction. GetPose will go through the poses array and return the first pose that has the direction in range.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.AimPoser.SetPoseActive(RootMotion.FinalIK.AimPoser.Pose)">
            <summary>
            Sets the pose active, increasing it's angle buffer.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Amplifier">
            <summary>
            Demo script that amplifies the motion of a body part relative to the root of the character or another body part.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Amplifier.Body">
            <summary>
            Body is amplifying the motion of "transform" relative to the "relativeTo".
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Amplifier.Body.EffectorLink">
            <summary>
            Linking this to an effector
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.BodyTilt">
            <summary>
            Procedural body tilting with FBBIK.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReaction">
            <summary>
            Class for creating procedural FBBIK hit reactions.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReaction.HitPoint">
            <summary>
            Hit point definition
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReaction.HitPointEffector">
            <summary>
            Hit Point for FBBIK effectors
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReaction.HitPointEffector.EffectorLink">
            <summary>
            Linking a FBBIK effector to this effector hit point
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReaction.HitPointBone">
            <summary>
            Hit Point for simple bone Transforms that don't have a FBBIK effector
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReaction.HitPointBone.BoneLink">
            <summary>
            Linking a bone Transform to this bone hit point
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.HitReaction.inProgress">
            <summary>
            Returns true if any of the hits are being processed.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReactionVRIK">
            <summary>
            Class for creating procedural FBBIK hit reactions.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReactionVRIK.Offset">
            <summary>
            Hit point definition
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReactionVRIK.PositionOffset">
            <summary>
            Hit Point for FBBIK effectors
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReactionVRIK.PositionOffset.PositionOffsetLink">
            <summary>
            Linking a FBBIK effector to this effector hit point
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReactionVRIK.RotationOffset">
            <summary>
            Hit Point for simple bone Transforms that don't have a FBBIK effector
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.HitReactionVRIK.RotationOffset.RotationOffsetLink">
            <summary>
            Linking a bone Transform to this bone hit point
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Inertia">
            <summary>
            Demo script that adds the illusion of mass to your character using FullBodyBipedIK.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Inertia.Body">
            <summary>
            Body is just following it's transform in a lazy and bouncy way.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Inertia.Body.EffectorLink">
            <summary>
            Linking this to an effector
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.OffsetModifier">
            <summary>
            Base class for all FBBIK effector positionOffset modifiers. Works with animatePhysics, safe delegates, offset limits.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.OffsetModifier.OffsetLimits">
            <summary>
            Limiting effector position offsets
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.OffsetModifierVRIK">
            <summary>
            Base class for all FBBIK effector positionOffset modifiers. Works with animatePhysics, safe delegates, offset limits.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.OffsetPose">
            <summary>
            Definition of FBBIK Offset pose.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.OffsetPose.EffectorLink">
            <summary>
            State of an effector in this pose
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.Recoil">
            <summary>
            Procedural recoil using FBBIK.
            </summary>
        </member>
        <member name="P:RootMotion.FinalIK.Recoil.isFinished">
            <summary>
            Returns true if recoil has finished or has not been called at all.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Recoil.SetHandRotations(UnityEngine.Quaternion,UnityEngine.Quaternion)">
            <summary>
            Sets the starting rotations for the hands for 1 frame. Use this if the final rotation of the hands will not be the same as before FBBIK solves.
            </summary>
        </member>
        <member name="M:RootMotion.FinalIK.Recoil.Fire(System.Single)">
            <summary>
            Starts the recoil procedure.
            </summary>
        </member>
        <member name="T:RootMotion.FinalIK.ShoulderRotator">
            <summary>
            Shoulder rotator is a workaround for FBBIK not rotating the shoulder bones when pulled by hands.
            It get's the job done if you need it, but will take 2 solving iterations.
            </summary>
        </member>
        <member name="T:RootMotion.Axis">
            <summary>
            The Cartesian axes.
            </summary>
        </member>
        <member name="T:RootMotion.AxisTools">
            <summary>
            Contains tools for working with Axes that have no positive/negative directions.
            </summary>
        </member>
        <member name="M:RootMotion.AxisTools.ToVector3(RootMotion.Axis)">
            <summary>
            Converts an Axis to Vector3.
            </summary>
        </member>
        <member name="M:RootMotion.AxisTools.ToAxis(UnityEngine.Vector3)">
            <summary>
            Converts a Vector3 to Axis.
            </summary>
        </member>
        <member name="M:RootMotion.AxisTools.GetAxisToPoint(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            Returns the Axis of the Transform towards a world space position.
            </summary>
        </member>
        <member name="M:RootMotion.AxisTools.GetAxisToDirection(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            Returns the Axis of the Transform towards a world space direction.
            </summary>
        </member>
        <member name="M:RootMotion.AxisTools.GetAxisVectorToPoint(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            Returns the local axis of the Transform towards a world space position.
            </summary>
        </member>
        <member name="M:RootMotion.AxisTools.GetAxisVectorToDirection(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            Returns the local axis of the Transform that aligns the most with a direction.
            </summary>
        </member>
        <member name="T:RootMotion.BipedLimbOrientations">
            <summary>
            Contains the information about which way the limbs should be bent.
            </summary>
        </member>
        <member name="M:RootMotion.BipedLimbOrientations.#ctor(RootMotion.BipedLimbOrientations.LimbOrientation,RootMotion.BipedLimbOrientations.LimbOrientation,RootMotion.BipedLimbOrientations.LimbOrientation,RootMotion.BipedLimbOrientations.LimbOrientation)">
            <summary>
            Initializes a new instance of the <see cref="!:RootMotion.FinalIK.FullBodyBipedBendDirections"/> class.
            </summary>
        </member>
        <member name="P:RootMotion.BipedLimbOrientations.UMA">
            <summary>
            Gets the local bend directions of the standard UMA skeleton.
            </summary>
        </member>
        <member name="P:RootMotion.BipedLimbOrientations.MaxBiped">
            <summary>
            Gets the local bend directions of the standard 3ds Max Biped skeleton.
            </summary>
        </member>
        <member name="T:RootMotion.BipedNaming">
            <summary>
            Class for identifying biped bones based on most common naming conventions.
            </summary>
        </member>
        <member name="T:RootMotion.BipedNaming.BoneType">
            <summary>
            Type of the bone.
            </summary>
        </member>
        <member name="T:RootMotion.BipedNaming.BoneSide">
            <summary>
            Bone side: Left and Right for limbs and Center for spine, head and tail.
            </summary>
        </member>
        <member name="M:RootMotion.BipedNaming.GetBonesOfType(RootMotion.BipedNaming.BoneType,UnityEngine.Transform[])">
            <summary>
            Returns only the bones with the specified BoneType.
            </summary>
        </member>
        <member name="M:RootMotion.BipedNaming.GetBonesOfSide(RootMotion.BipedNaming.BoneSide,UnityEngine.Transform[])">
            <summary>
            Returns only the bones with the specified BoneSide.
            </summary>
        </member>
        <member name="M:RootMotion.BipedNaming.GetBonesOfTypeAndSide(RootMotion.BipedNaming.BoneType,RootMotion.BipedNaming.BoneSide,UnityEngine.Transform[])">
            <summary>
            Gets the bones of type and side.
            </summary>
        </member>
        <member name="M:RootMotion.BipedNaming.GetFirstBoneOfTypeAndSide(RootMotion.BipedNaming.BoneType,RootMotion.BipedNaming.BoneSide,UnityEngine.Transform[])">
            <summary>
            Gets the bone of type and side. If more than one is found, will return the first in the array.
            </summary>
        </member>
        <member name="M:RootMotion.BipedNaming.GetNamingMatch(UnityEngine.Transform[],System.String[][])">
            <summary>
            Returns only the bones that match all the namings in params string[][] namings
            </summary>
            <returns>
            The matching Transforms
            </returns>
            <param name='transforms'>
            Transforms.
            </param>
            <param name='namings'>
            Namings.
            </param>
        </member>
        <member name="M:RootMotion.BipedNaming.GetBoneType(System.String)">
            <summary>
            Gets the type of the bone.
            </summary>
        </member>
        <member name="M:RootMotion.BipedNaming.GetBoneSide(System.String)">
            <summary>
            Gets the bone side.
            </summary>
        </member>
        <member name="M:RootMotion.BipedNaming.GetBone(UnityEngine.Transform[],RootMotion.BipedNaming.BoneType,RootMotion.BipedNaming.BoneSide,System.String[][])">
            <summary>
            Returns the bone of type and side with additional naming parameters.
            </summary>
        </member>
        <member name="T:RootMotion.BipedReferences">
            <summary>
            Contains references to bones common to all biped characters.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.root">
            <summary>
            The root transform is the parent of all the biped's bones and should be located at ground level.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.pelvis">
            <summary>
            The pelvis (hip) bone.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.leftThigh">
            <summary>
            The first bone of the left leg.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.leftCalf">
            <summary>
            The second bone of the left leg.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.leftFoot">
            <summary>
            The third bone of the left leg.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.rightThigh">
            <summary>
            The first bone of the right leg.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.rightCalf">
            <summary>
            The second bone of the right leg.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.rightFoot">
            <summary>
            The third bone of the right leg.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.leftUpperArm">
            <summary>
            The first bone of the left arm.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.leftForearm">
            <summary>
            The second bone of the left arm.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.leftHand">
            <summary>
            The third bone of the left arm.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.rightUpperArm">
            <summary>
            The first bone of the right arm.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.rightForearm">
            <summary>
            The second bone of the right arm.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.rightHand">
            <summary>
            The third bone of the right arm.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.head">
            <summary>
            The head.
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.spine">
            <summary>
            The spine hierarchy. Should not contain any bone deeper in the hierarchy than the arms (neck or head).
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.eyes">
            <summary>
            The eyes.
            </summary>
        </member>
        <member name="P:RootMotion.BipedReferences.isFilled">
            <summary>
            Check for null references.
            </summary>
        </member>
        <member name="P:RootMotion.BipedReferences.isEmpty">
            <summary>
            Gets a value indicating whether this <see cref="T:RootMotion.BipedReferences"/> is empty.
            </summary>
        </member>
        <member name="M:RootMotion.BipedReferences.IsEmpty(System.Boolean)">
            <summary>
            Gets a value indicating whether this <see cref="T:RootMotion.BipedReferences"/> is empty. If includeRoot is false, returns true(is empty) even if root Transform has been assigned.
            </summary>
        </member>
        <member name="M:RootMotion.BipedReferences.Contains(UnityEngine.Transform,System.Boolean)">
            <summary>
            Returns true if the References contain the specified Transform
            </summary>
        </member>
        <member name="T:RootMotion.BipedReferences.AutoDetectParams">
            <summary>
            Params for automatic biped recognition. (Using a struct here because I might need to add more parameters in the future).
            </summary>
        </member>
        <member name="F:RootMotion.BipedReferences.AutoDetectParams.legsParentInSpine">
            <summary>
            Should the immediate parent of the legs be included in the spine?.
            </summary>
        </member>
        <member name="M:RootMotion.BipedReferences.AutoDetectReferences(RootMotion.BipedReferences@,UnityEngine.Transform,RootMotion.BipedReferences.AutoDetectParams)">
            <summary>
            Automatically detects biped bones. Returns true if a valid biped has been referenced.
            </summary>
        </member>
        <member name="M:RootMotion.BipedReferences.DetectReferencesByNaming(RootMotion.BipedReferences@,UnityEngine.Transform,RootMotion.BipedReferences.AutoDetectParams)">
            <summary>
            Detects the references based on naming and hierarchy.
            </summary>
        </member>
        <member name="M:RootMotion.BipedReferences.AssignHumanoidReferences(RootMotion.BipedReferences@,UnityEngine.Animator,RootMotion.BipedReferences.AutoDetectParams)">
            <summary>
            Fills in BipedReferences using Animator.GetBoneTransform().
            </summary>
        </member>
        <member name="M:RootMotion.BipedReferences.SetupError(RootMotion.BipedReferences,System.String@)">
            <summary>
            Checks the setup for definite problems.
            </summary>
        </member>
        <member name="M:RootMotion.BipedReferences.SetupWarning(RootMotion.BipedReferences,System.String@)">
            <summary>
            Checks the setup for possible problems.
            </summary>
        </member>
        <member name="T:RootMotion.Comments">
            <summary>
            Adding comments to GameObjects in the Inspector.
            </summary>
        </member>
        <member name="F:RootMotion.Comments.text">
            <summary>
            The comment.
            </summary>
        </member>
        <member name="T:RootMotion.Hierarchy">
            <summary>
            Contains tools for working on Transform hierarchies.
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.HierarchyIsValid(UnityEngine.Transform[])">
            <summary>
            Make sure the bones are in valid %Hierarchy
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.ContainsDuplicate(UnityEngine.Object[])">
            <summary>
            Checks if an array of objects contains any duplicates.
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.IsAncestor(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Determines whether the second Transform is an ancestor to the first Transform.
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.ContainsChild(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Returns true if the transforms contains the child
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.AddAncestors(UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform[]@)">
            <summary>
            Adds all Transforms until the blocker to the array
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.GetAncestor(UnityEngine.Transform,System.Int32)">
            <summary>
            Gets the last ancestor that has more than minChildCount number of child Transforms 
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.GetFirstCommonAncestor(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Gets the first common ancestor up the hierarchy
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.GetFirstCommonAncestor(UnityEngine.Transform[])">
            <summary>
            Gets the first common ancestor of the specified transforms.
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.GetFirstCommonAncestorRecursive(UnityEngine.Transform,UnityEngine.Transform[])">
            <summary>
            Gets the first common ancestor recursively.
            </summary>
        </member>
        <member name="M:RootMotion.Hierarchy.IsCommonAncestor(UnityEngine.Transform,UnityEngine.Transform[])">
            <summary>
            Determines whether the first parameter is the common ancestor of all the other specified transforms.
            </summary>
        </member>
        <member name="T:RootMotion.InterpolationMode">
            <summary>
            Interpolation mode.
            </summary>
        </member>
        <member name="T:RootMotion.Interp">
            <summary>
            Class for various interpolation methods.
            </summary>
        </member>
        <member name="M:RootMotion.Interp.Float(System.Single,RootMotion.InterpolationMode)">
            <summary>
            Interpolate the specified t by InterpolationMode mode.
            </summary>
            <param name='t'>
            T.
            </param>
            <param name='mode'>
            InterpolationMode.
            </param>
        </member>
        <member name="M:RootMotion.Interp.V3(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,RootMotion.InterpolationMode)">
            <summary>
            Interpolate between two verctors by InterpolationMode mode
            </summary>
        </member>
        <member name="M:RootMotion.Interp.LerpValue(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Linear interpolation of value towards target.
            </summary>
        </member>
        <member name="T:RootMotion.LargeHeader">
            <summary>
            Large header attribute for Editor.
            </summary>
        </member>
        <member name="T:RootMotion.LayerMaskExtensions">
            <summary>
            This class contains tools for working with LayerMasks. 
            Most of this was copied from Unity Wiki: http://wiki.unity3d.com/index.php?title=LayerMaskExtensions.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.Contains(UnityEngine.LayerMask,System.Int32)">
            <summary>
            Does the LayerMask contain a specific layer index?
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.Create(System.String[])">
            <summary>
            Creates a LayerMask from an array of layer names.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.Create(System.Int32[])">
            <summary>
            Creates a LayerMask from an array of layer indexes.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.NamesToMask(System.String[])">
            <summary>
            Creates a LayerMask from a number of layer names.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.LayerNumbersToMask(System.Int32[])">
            <summary>
            Creates a LayerMask from a number of layer indexes.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.Inverse(UnityEngine.LayerMask)">
            <summary>
            Inverts a LayerMask.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.AddToMask(UnityEngine.LayerMask,System.String[])">
            <summary>
            Adds a number of layer names to an existing LayerMask.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.RemoveFromMask(UnityEngine.LayerMask,System.String[])">
            <summary>
            Removes a number of layer names from an existing LayerMask.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.MaskToNames(UnityEngine.LayerMask)">
            <summary>
            Returns a string array of layer names from a LayerMask.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.MaskToNumbers(UnityEngine.LayerMask)">
            <summary>
            Returns an array of layer indexes from a LayerMask.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.MaskToString(UnityEngine.LayerMask)">
            <summary>
            Parses a LayerMask to a string.
            </summary>
        </member>
        <member name="M:RootMotion.LayerMaskExtensions.MaskToString(UnityEngine.LayerMask,System.String)">
            <summary>
            Parses a LayerMask to a string using the specified delimiter.
            </summary>
        </member>
        <member name="T:RootMotion.QuaTools">
            <summary>
            Helper methods for dealing with Quaternions.
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.Lerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
            <summary>
            Optimized Quaternion.Lerp
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.Slerp(UnityEngine.Quaternion,UnityEngine.Quaternion,System.Single)">
            <summary>
            Optimized Quaternion.Slerp
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.LinearBlend(UnityEngine.Quaternion,System.Single)">
            <summary>
            Returns the rotation from identity Quaternion to "q", interpolated linearily by "weight".
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.SphericalBlend(UnityEngine.Quaternion,System.Single)">
            <summary>
            Returns the rotation from identity Quaternion to "q", interpolated spherically by "weight".
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.FromToAroundAxis(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Creates a FromToRotation, but makes sure it's axis remains fixed near to the Quaternion singularity point.
            </summary>
            <returns>
            The from to rotation around an axis.
            </returns>
            <param name='fromDirection'>
            From direction.
            </param>
            <param name='toDirection'>
            To direction.
            </param>
            <param name='axis'>
            Axis. Should be normalized before passing into this method.
            </param>
        </member>
        <member name="M:RootMotion.QuaTools.RotationToLocalSpace(UnityEngine.Quaternion,UnityEngine.Quaternion)">
            <summary>
            Gets the rotation that can be used to convert a rotation from one axis space to another.
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.FromToRotation(UnityEngine.Quaternion,UnityEngine.Quaternion)">
            <summary>
            Gets the Quaternion from rotation "from" to rotation "to".
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.GetAxis(UnityEngine.Vector3)">
            <summary>
            Gets the closest direction axis to a vector. Input vector must be normalized!
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.ClampRotation(UnityEngine.Quaternion,System.Single,System.Int32)">
            <summary>
            Clamps the rotation similar to V3Tools.ClampDirection.
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.ClampAngle(System.Single,System.Single,System.Int32)">
            <summary>
            Clamps an angular value.
            </summary>
        </member>
        <member name="M:RootMotion.QuaTools.MatchRotation(UnityEngine.Quaternion,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Used for matching the rotations of objects that have different orientations.
            </summary>
        </member>
        <member name="T:RootMotion.Singleton`1">
            <summary>
            The base abstract Singleton class.
            </summary>
        </member>
        <member name="T:RootMotion.SolverManager">
            <summary>
            Manages solver initiation and updating
            </summary>
        </member>
        <member name="F:RootMotion.SolverManager.fixTransforms">
            <summary>
            If true, will fix all the Transforms used by the solver to their initial state in each Update. This prevents potential problems with unanimated bones and animator culling with a small cost of performance. Not recommended for CCD and FABRIK solvers.
            </summary>
        </member>
        <member name="M:RootMotion.SolverManager.Disable">
            <summary>
            [DEPRECATED] Use "enabled = false" instead.
            </summary>
        </member>
        <member name="T:RootMotion.TriggerEventBroadcaster">
            <summary>
            Forwards collider OnTrigger.. events.
            </summary>
        </member>
        <member name="T:RootMotion.V3Tools">
            <summary>
            Helper methods for dealing with 3-dimensional vectors.
            </summary>
        </member>
        <member name="M:RootMotion.V3Tools.Lerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Optimized Vector3.Lerp
            </summary>
        </member>
        <member name="M:RootMotion.V3Tools.Slerp(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Optimized Vector3.Slerp
            </summary>
        </member>
        <member name="M:RootMotion.V3Tools.ExtractVertical(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Returns vector projection on axis multiplied by weight.
            </summary>
        </member>
        <member name="M:RootMotion.V3Tools.ExtractHorizontal(UnityEngine.Vector3,UnityEngine.Vector3,System.Single)">
            <summary>
            Returns vector projected to a plane and multiplied by weight.
            </summary>
        </member>
        <member name="M:RootMotion.V3Tools.ClampDirection(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,System.Boolean@)">
            <summary>
            Clamps the direction to clampWeight from normalDirection, clampSmoothing is the number of sine smoothing iterations applied on the result.
            </summary>
        </member>
        <member name="M:RootMotion.V3Tools.ClampDirection(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Int32,System.Single@)">
            <summary>
            Clamps the direction to clampWeight from normalDirection, clampSmoothing is the number of sine smoothing iterations applied on the result.
            </summary>
        </member>
        <member name="M:RootMotion.V3Tools.LineToPlane(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Get the intersection point of line and plane
            </summary>
        </member>
        <member name="M:RootMotion.V3Tools.PointToPlane(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Projects a point to a plane.
            </summary>
        </member>
        <member name="T:RootMotion.Warning">
            <summary>
            Manages warning messages.
            </summary>
        </member>
    </members>
</doc>
